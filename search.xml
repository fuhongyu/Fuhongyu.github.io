<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/23/hello-world/"/>
      <url>/2018/12/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java高并发程序设计知识总结</title>
      <link href="/2018/12/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>最近把《实战java高并发程序设计》一书看了两遍，很多知识不加积累很快就忘记了，在此对java高并发这块知识进行总结，一方面自己回顾方法，另一方面可以给大家提供方便。</p><ul><li><h4 id="线程的母亲——进程"><a href="#线程的母亲——进程" class="headerlink" title="线程的母亲——进程"></a>线程的母亲——进程</h4><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li></ul></li><li><h4 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h4><ul><li>同步（Synchronous）和异步(Asynchronous)：同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的工作。</li><li>并发(Concurrency)和并行(Parallelism)：并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。</li><li>临界区：用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。在并行程序中，临界区资源是保护的对象。</li><li>阻塞（Blocking）和非阻塞(Non-Blocking)：他们用来形容多线程间的相互影响。如一个线程占用了临界区资源，那么其他所有需要这个资源的线程都必须等待，导致线程挂起，即阻塞。资源不释放，所有阻塞在临界区上的线程都不能工作。非阻塞与之相反，它指没有一个线程可以妨碍其他线程的执行。</li><li>死锁（DeadLock）：多个线程彼此占用了其他线程所需要的资源，得不到需要的资源，又不释放已得到的资源。</li><li>饥饿（Starvation）：指某一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。（如线程的优先级太低）还有一种情况，某一个线程一直占着资源不释放，导致其他需要这个资源的线程无法正常执行，与死锁相比，饥饿是有可能在未来一段时间内解决的。</li><li>活锁（LiveLock）：两个线程间，秉承“谦让”的原则，主动将资源释放给他人使用，可能会出现资源在两个线程中跳动，没有一个线程可以同时拿到所有资源而正常执行。</li></ul></li><li><h4 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h4><ul><li>阻塞（Blocking）：一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。使用synchronized关键字和ReentrantLock（重入锁）得到的就是阻塞线程。阻塞的控制方式是悲观策略。</li><li>无饥饿（Starvation-Free）：如果锁是公平的，满足先来后到，那饥饿就不会产生。</li><li>无障碍（Obstruction-Free）：无障碍是一种最弱的非阻塞调度。两个线程是无障碍地执行，那它们不会因为临界区的问题导致一方挂起，大家都可以大摇大摆地进入临界区。如果两个线程一起修改数据导致数据改坏了，则进行回滚， 保证数据安全。若没有数据竞争，则线程顺利完成工作，走出临界区。非阻塞的调度是一种乐观的策略。一种可行的无障碍实现可以依赖一个“一致性标记”来实现。</li><li>无锁（Lock-Free）：无锁的并行都是无障碍的。无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。如CAS操作。</li><li>无等待（Wait-Free）：它要求所有线程都必须在有限步内完成，这样就不会引起饥饿问题。</li></ul></li><li><h4 id="为什么要使用并行"><a href="#为什么要使用并行" class="headerlink" title="为什么要使用并行"></a>为什么要使用并行</h4><ul><li>为了获得更好的性能。</li><li>由于业务模型的需要，确实需要多个执行实体。</li></ul></li><li><h4 id="有关并行的两个重要定律"><a href="#有关并行的两个重要定律" class="headerlink" title="有关并行的两个重要定律"></a>有关并行的两个重要定律</h4><ul><li>Amdahl定律：加速比定义：加速比=优化前系统耗时/优化后系统耗时。 Amdahl定律强调，当串行比例一定时，加速比是有上限的，不管你堆叠多少CPU参与计算，都不能突破这个上限！</li><li>Gustafson定律：其关心的是：如果可被并行化的代码所占比重足够多，那么加速比就可以随着CPU的数量线性增长。</li></ul></li><li><h4 id="java内存模型（JMM）"><a href="#java内存模型（JMM）" class="headerlink" title="java内存模型（JMM）"></a>java内存模型（JMM）</h4><ul><li>原子性（Atomicity）: 原子性指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。对于32系统来说，Long类型的数据的读写不是原子性的（long有64位）。</li><li>可见性（Visibility）: 可见性是指当一个线程修改了某一个共享变量，其他线程是否能够立即知道这个修改。</li><li>有序性（Ordering）：单线程环境下，指令从前往后执行；多线程环境下，可能会进行指令重排，重排后的指令与原指令顺序未必一致。指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。</li></ul></li><li><h4 id="Happen-Before原则"><a href="#Happen-Before原则" class="headerlink" title="Happen-Before原则"></a>Happen-Before原则</h4><ul><li>程序顺序原则：一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性。</li><li>锁规则：解锁必然发生在随后的加锁前。</li><li>传递性：A先于B，B先于C，那么A必然先于C</li><li>线程的start()方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结（Thread.join()）</li><li>线程的中断（interrupt（））先于被中断线程的代码</li><li>对象的构造函数执行、结束先于finalize()方法</li></ul></li><li><h3 id="java并行程序基础"><a href="#java并行程序基础" class="headerlink" title="java并行程序基础"></a>java并行程序基础</h3><ul><li><h4 id="线程状态转换："><a href="#线程状态转换：" class="headerlink" title="线程状态转换："></a>线程状态转换：</h4><p><img src="https://img.mubu.com/document_image/e1375cab-d57b-44a2-9a35-aed41db90124-2160256.jpg" alt="img"></p><ul><li>新建（New）：创建后尚未启动。</li><li>可运行（Runnable）：可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态中的 Running 和 Ready。</li><li>阻塞（Blocking）: 等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li><li>无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</li><li>限期等待（Timed Waiting）无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</li><li>死亡（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束。</li></ul></li><li><h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h4><ul><li>实现Runnable接口</li><li>实现Callable接口</li><li>继承Thread类</li><li>说明：实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</li><li>三种实现方式的比较：<ul><li>实现Runnable接口可以避免Java单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。</li><li>继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法。</li><li>实现Callable接又要实现call方法，并且线程执行完毕后会有返回值。其他的两种都是重写run方法，没有返回值。</li><li>实现接口会更好一些，因为：①Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；②类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul></li></ul></li><li><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><ul><li>Thread.stop()方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。若此时线程写入数据写到一半，并强行终止，那么对象就会被写坏，另一个线程读到不一致的对象。所以，不建议使用Thread.stop() 来终止线程</li><li>解决：可以定义一个标记变量 stopme, 用于指示线程是否需要退出，当调用线程终止方法（stopMe()）,stopme被设置为true,单线程执行到此，检测到改动，自然退出，不会使对象的状态出现错误。</li></ul></li><li><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><ul><li>Thread.interrupt() : 是实例方法，通知目标线程中断，即设置中断标志位。</li><li>Thread.isInterrupted() ：是实例方法，判断当前线程是否有被中断。</li><li>Thread.interrupted() ：静态方法，判断当前线程的中断状态，但同时会清除当前线程的中断标志位状态</li></ul></li><li><h4 id="等待（wait）和通知（notify）"><a href="#等待（wait）和通知（notify）" class="headerlink" title="等待（wait）和通知（notify）"></a>等待（wait）和通知（notify）</h4><ul><li>object.wait()：如果一个线程调用了object.wait()，那么它就会进入object 对象的等待队列，这个等待队列，可能会有多个线程同时等待某一个对象。</li><li>object.notify()：如果object.notify()被调用时，它就会从这个等待队列中，随机选择一个线程，并将其唤醒。（注意：这个选择是不公平，随机的）</li><li>说明：object.wait()不能随便调用，它必须包含在对应的synchronized语句中，无论是wait()或者notify()都需要首先获得目标对象的一个监视器</li><li>object.wait()和Thread.sleep() : 两个方法都可以让线程等待若干时间，除了wait()可以被唤醒外，另外一个主要的区别就是wait()方法会释放目标对象的锁，Tread.sleep()方法不会释放任何资源。</li></ul></li><li><h4 id="挂起（suspend）和继续执行（resume）线程"><a href="#挂起（suspend）和继续执行（resume）线程" class="headerlink" title="挂起（suspend）和继续执行（resume）线程"></a>挂起（suspend）和继续执行（resume）线程</h4><ul><li>suspend在导致线程暂停的同时，并不会去释放任何锁资源。此时，其他线程想要访问被它暂用的锁时，都会被牵连，导致无法正常继续运行。直到对应的线程上进行了resume()操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。所以不推荐使用suspend()去挂起线程</li><li>另外，如果resume()操作意外地在suspend()前就释放了，那么挂起的线程可能很难有机会继续执行。并且，更严重的是，它所占用的锁不会释放，因此可能导致整个系统工作不正常。（被挂起的线程，处于Runnable状态，让我们没办法对系统当前状态进行判断呀）</li></ul></li><li><h4 id="等待线程结束（join）和谦让（yield）"><a href="#等待线程结束（join）和谦让（yield）" class="headerlink" title="等待线程结束（join）和谦让（yield）"></a>等待线程结束（join）和谦让（yield）</h4><ul><li>join() 表示无限时等待，它会一直阻塞当前线程，直到目标线程执行完毕。join()的本质是让调用线程wait()在当前线程对象实例上。（调用线程等待当前线程）</li><li>join(long millis) 给出最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因“等不及了”，而继续往下执行。</li><li>Thread.yield()：是一个静态方法，一旦执行，会使当前线程让出CPU。但要注意，让出CPU并不表示当前线程不执行了，当前线程在让出CPU后，还会进行CPU资源的争夺，但能否再次分配到就不一定了。</li></ul></li><li><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><ul><li>当用volatile去声明一个变量的时候，就等于告诉了虚拟机，这个变量极有可能会被某些程序或者线程修改。</li><li>volatile能保证数据的可见性和有序性，不能保证原子性。</li></ul></li><li><h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><ul><li>ThreadGroup tg = new ThreadGroup(“ThreadGroup name”); 在创建线程和线程组的时候，给他们取一个好听的名字。</li></ul></li><li><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li>守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地完成一些系统性的服务，比如垃圾回收线程，JIT线程可以理解为守护线程。</li><li>当一个java应用内，只有守护线程时，java虚拟机就会自然退出。</li><li>t.setDaemon(true); 将一个线程设置为守护线程。</li></ul></li><li><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>在java中，使用1-10表示线程优先级，数字越大优先级越高</li><li>public final static int MIN_PRIORITY = 1;</li><li>public final static int NORM_PRIORITY = 5;</li><li>public final static int MAX_PRIORITY = 10;</li><li>thread.setPriority(Thread.MAX_PRIORITY ) // 为一个线程设置优先级</li></ul></li><li><h4 id="synchronized-的加锁方式"><a href="#synchronized-的加锁方式" class="headerlink" title="synchronized 的加锁方式"></a>synchronized 的加锁方式</h4><ul><li>同步一个代码块 ： 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</li><li>同步一个方法 ： 它和同步代码块一样，作用于同一个对象。</li><li>同步一个类： 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li><li>同步一个静态方法： 作用于整个类。</li></ul></li></ul></li><li><h3 id="JDK并发包："><a href="#JDK并发包：" class="headerlink" title="JDK并发包："></a>JDK并发包：</h3><ul><li><h4 id="同步控制："><a href="#同步控制：" class="headerlink" title="同步控制："></a>同步控制：</h4><ul><li><h5 id="ReentrantLock（重入锁-）"><a href="#ReentrantLock（重入锁-）" class="headerlink" title="ReentrantLock（重入锁 ）"></a>ReentrantLock（重入锁 ）</h5><ul><li>重入锁可以完全替代synchronized关键字，使用 java.util.concurrent.locks.ReentrantLock 类来实现。“重入”？：这种锁是可以反复进入的(这里的反复仅仅局限于一个线程),如果一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数的锁。</li><li>Synchronized与ReentrantLock比较：<ul><li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断: 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li></ul></li><li>lock.lock() 和 lock.lockInterruptibly()的区别：<ul><li>lock() 优先获得锁</li><li>lockInterruptibly() 优先相应中断</li></ul></li><li>锁申请等待限时 tryLock：<ul><li>lock.tryLock(5, TimeUnit.SECONDS) 参数表示等待时常， 计时单位</li><li>lock.tryLock(）不带参数时，申请锁成功立即返回true,申请失败，不会等待，立即返回false.</li></ul></li></ul></li><li><h5 id="Condition条件"><a href="#Condition条件" class="headerlink" title="Condition条件:"></a>Condition条件:</h5><ul><li>ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); //新建一个与lock绑定的condition对象</li><li>condition.await(); //让线程在Condition对象上等待，线程调用condition.await()时，要求线程持有相关的重入锁，在condition.await()调用之后，线程会释放这把锁</li><li>condition.signal(); //唤醒线程，condition.signal()方法调用时，也要求线程先获得相关的锁，在signal()方法调用之后，系统会从当前condition对象的等待队列中，唤醒一个线程。</li><li>ArrayBlockingQueue 的put()和take()方法使用的重入锁和Condition条件。</li></ul></li><li><h5 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）:"></a>信号量（Semaphore）:</h5><ul><li>信号量可以指定多个线程同时访问某个资源。</li><li>Semaphore semp = new Semaphore(5); //构造信号量对象，必须指定信号量准入数。</li><li>aquire() 方法尝试获得一个准入的许可。</li><li>acquireUninterruptibly() 不响应中断。</li><li>release() 用于在线程访问资源结束后，释放一个许可</li></ul></li><li><h5 id="读写锁（ReadWriteLock）："><a href="#读写锁（ReadWriteLock）：" class="headerlink" title="读写锁（ReadWriteLock）："></a>读写锁（ReadWriteLock）：</h5><ul><li>ReadWriteLock是jdk5中提供的读写分离锁，读写锁允许多个线程同时读，写写操作和读写操作间依然是需要相互等待和持有锁的。</li><li>ReentrantReadWriteLock readWritelock = new ReentrantReadWriteLock(); Lock readLock = readWritelock .readLock(); Lock writeLock = readWritelock .writeLock();</li></ul></li><li><h5 id="倒计时器-CountDownLatch"><a href="#倒计时器-CountDownLatch" class="headerlink" title="倒计时器(CountDownLatch):"></a>倒计时器(CountDownLatch):</h5><ul><li>控制线程等待，让某一线程等待直到倒计时结束，再开始执行。</li><li>CountDownLatch.countdown(); //通知CountDownLatch 一个线程已经完成，倒计时器可以减1了。</li><li>CountDownLatch.await(); //主线等待所有任务全部完成再往下执行</li></ul></li><li><h5 id="循环栅栏（CyclicBarrier）"><a href="#循环栅栏（CyclicBarrier）" class="headerlink" title="循环栅栏（CyclicBarrier）:"></a>循环栅栏（CyclicBarrier）:</h5><ul><li>和CountDownLatch非常类似，但功能更加复杂且强大</li></ul></li><li><h5 id="线程阻塞工具类（LockSupport）"><a href="#线程阻塞工具类（LockSupport）" class="headerlink" title="线程阻塞工具类（LockSupport）:"></a>线程阻塞工具类（LockSupport）:</h5><ul><li>它可以在线程内任意位置让线程阻塞，和Thread.suspend()相比，它弥补了由于resume() 在前发生，导致线程无法继续执行的情况。</li><li>LockSupport.park()；//挂起线程 LockSupport.unpark() //让线程继续执行。</li><li>LockSupport 类使用类似信号量的机制，它为每一个线程准备了一个许可，如果许可可用，那么park()函数会立即返回，并且消费这个许可（即将许可变为不可用），如果许可不可用，就会阻塞，而unpark()则是使一个许可变为可用（但是和信号量不同的是，许可不能累加，你不可能拥有超过一个许可，他永远只有一个）。即使unpack() 操作发生在pack() 之前，它也可以使下一次的park() 操作立即返回。</li><li>park() 挂起状态的线程，会非常明确地给出一个WAITING状态，甚至还会标注是park() 引起的。</li></ul></li></ul></li><li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4></li><li><h4 id="JDK的并发容器"><a href="#JDK的并发容器" class="headerlink" title="JDK的并发容器"></a>JDK的并发容器</h4><ul><li><p>ConcurrentHashMap：位于java.util.concurrent 包内，是线程安全的HashMap</p></li><li><p>CopyOnWriteArrayList:</p></li><li><p>ConcurrentLinkedQueue:</p></li><li><p>BlockingQueue:</p></li><li><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap:"></a>ConcurrentSkipListMap:</h3></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>剑指Offer-48 ：最长不含重复字符的子字符串</title>
      <link href="/2018/12/21/%E5%89%91%E6%8C%87Offer-%E9%A2%9848%20%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/21/%E5%89%91%E6%8C%87Offer-%E9%A2%9848%20%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：最长不含重复字符的子字符串"><a href="#题目：最长不含重复字符的子字符串" class="headerlink" title="题目：最长不含重复字符的子字符串"></a>题目：最长不含重复字符的子字符串</h3><p>​      请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p><p><strong>主要思路：</strong></p><p>使用动态规划，记录当前字符之前的最长非重复子字符串长度f(i-1)，其中i为当前字符的位置。每次遍历当前字符时，分两种情况进行讨论：</p><ol><li>若当前字符第一次出现，则最长非重复子字符串长度f(i) = f(i-1)+1。 </li><li>若当前字符不是第一次出现，则首先计算当前字符与它上次出现位置之间的距离d。<br>若d大于f(i-1)，即说明前一个非重复子字符串中没有包含当前字符，则可以添加当前字符到前一个非重复子字符串中，所以，f(i) = f(i-1)+1。<br>若d小于或等于f(i-1)，即说明前一个非重复子字符串中已经包含当前字符，则不可以添加当前字符，所以，f(i) = d。</li></ol><p><strong>java代码实现：</strong></p><hr><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> offer<span class="token punctuation">.</span>coder<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TheMaxNoRepeatString48</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//测试代码</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMaxNoRepeatString</span><span class="token punctuation">(</span><span class="token string">"abaacdwq"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMaxNoRepeatString</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> position <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化位置数组position</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> position<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            position<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 定位元素在数组中的下标 </span>            <span class="token keyword">int</span> index <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 上一个元素出现的位置</span>            <span class="token keyword">int</span> prePosition <span class="token operator">=</span> position<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算此次出现距上次出现的距离</span>            <span class="token keyword">int</span> distance <span class="token operator">=</span> i <span class="token operator">-</span> prePosition<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//距离 > 当前长度 ; 忽略，长度+1，继续判断下一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>prePosition <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> distance <span class="token operator">></span> curLength<span class="token punctuation">)</span><span class="token punctuation">{</span>                  curLength<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                curLength <span class="token operator">=</span> distance<span class="token punctuation">;</span>                maxLength <span class="token operator">=</span> maxLength <span class="token operator">></span> curLength <span class="token operator">?</span> maxLength <span class="token operator">:</span> curLength<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                position<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxLength <span class="token operator">></span> curLength <span class="token operator">?</span> maxLength <span class="token operator">:</span> curLength<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如何解释关系数据库的第一第二第三范式？</title>
      <link href="/2018/12/20/%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F/"/>
      <url>/2018/12/20/%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。</p><h6 id="本文转自知乎刘慰教师"><a href="#本文转自知乎刘慰教师" class="headerlink" title="本文转自知乎刘慰教师"></a>本文转自知乎<a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">刘慰教师</a></h6><h1 id="范式介绍"><a href="#范式介绍" class="headerlink" title="范式介绍"></a>范式介绍</h1><p>   首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><h2 id="1NF的定义为：符合1NF的关系中的每个属性都不可再分。"><a href="#1NF的定义为：符合1NF的关系中的每个属性都不可再分。" class="headerlink" title="1NF的定义为：符合1NF的关系中的每个属性都不可再分。"></a>1NF的定义为：符合1NF的关系中的每个属性都不可再分。</h2><p>符合1NF的关系（你可以理解为数据表。“关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。<br>表1所示的情况，就不符合1NF的要求：</p><p><img src="https://img-blog.csdnimg.cn/20181220111349147.png" alt="表1"></p><p>实际上，<strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，<strong>只要在RDBMS中已经存在的数据表，一定是符合1NF的</strong>。<br>如果我们要在RDBMS中表现表中的数据，就得设计为表2的形式：</p><p> <img src="https://img-blog.csdnimg.cn/20181220111517383.png" alt="表2"><br>但是仅仅符合1NF的设计，仍然会存在<strong>数据冗余过大，插入异常，删除异常，修改异常</strong>的问题，例如对于表3中的设计：<br><img src="https://img-blog.csdnimg.cn/20181220111559788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="表3"></p><ol><li>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——<strong>数据冗余过大</strong></li><li>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 ——<strong>插入异常</strong><br>根据三种关系完整性约束中实体完整性的要求，关系中的<strong>码</strong>所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将<strong>学号与课名的组合</strong>作为码，否则就无法唯一地区分每一条记录。[<strong>码</strong>：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）]。</li><li>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong></li><li><p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。<br>正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。</p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><h2 id="2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。"><a href="#2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。" class="headerlink" title="2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。"></a>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。</h2><p>第二范式（2NF）在关系理论中的严格定义我这里就不多介绍了（因为涉及到的铺垫比较多），只需要了解2NF对1NF进行了哪些改进即可。其改进是，2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。接下来对这句话中涉及到的四个概念———<strong>“函数依赖”、“码”、“非主属性”、与“部分函数依赖” </strong>进行一下解释。</p></li></ol><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>我们可以这么理解（但并不是特别严格的定义）：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说<strong>Y函数依赖于X，写作 X → Y</strong>。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也  就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。</p><p>例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说<strong>姓名函数依赖于学号，写作 学号 → 姓名</strong>。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。</p><p> <strong>表中,其他的函数依赖关系还有如：</strong></p><ul><li>系名 → 系主任</li><li>学号 → 系主任</li><li><p>（学号，课名） → 分数</p><p><strong>但以下函数依赖关系则不成立：</strong></p></li><li>学号 → 课名</li><li>学号 → 分数</li><li>课名 → 系主任</li><li>（学号，课名）→ 姓名<br>从“函数依赖”这个概念展开，还会有三个概念：<h5 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h5>在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ‘ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作：<br><img src="https://img-blog.csdnimg.cn/20181220113000872.png" alt="无"><br>例如： 学号 F→ 姓名 （学号，课名） F→ 分数  （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）</li></ul><h5 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h5><p>假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 ：<br><img src="https://img-blog.csdnimg.cn/20181220113146810.png" alt="在这里插入图片描述"><br>例如：（学号，课名） P→ 姓名</p><h5 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h5><p>假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （基于『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作：<br><img src="https://img-blog.csdnimg.cn/20181220141747431.png" alt="在这里插入图片描述"></p><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都<strong>完全函数依赖</strong>于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。<br>在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。<br>一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为<strong>主码</strong>）<br>例如：对于表3，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）</p><h3 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h3><p>包含在任何一个码中的属性成为主属性。<br>例如：<br>对于表3，主属性就有两个，学号 与 课名。</p><p>终于可以回过来看2NF了。<br>首先，我们需要判断，表3是否符合2NF的要求？<br>根据2NF的定义，判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。<br><strong>判断的方法是：</strong><br>第一步：找出数据表中所有的码。<br>第二步：根据第一步所得到的码，找出所有的主属性。<br>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<br>第四步：查看是否存在非主属性对码的部分函数依赖。<br>对于表3，根据前面所说的四步，<strong>我们可以这么做</strong>：<br>第一步：查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。……查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“完全函数依赖”）。<br>图4表示了表中所有的函数依赖关系：<br><img src="https://img-blog.csdnimg.cn/20181220143506956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="图4"></p><p>这一步完成以后，可以得到，表3的码只有一个，就是（学号、课名）。<br>第二步：主属性有两个：学号 与 课名<br>第三步：非主属性有四个：姓名、系名、系主任、分数<br>第四步：对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 <strong>姓名</strong> 对码（学号，课名）的部分函数依赖。<br>对于（学号，课名）→ 系名，有 学号 → 系名，存在非主属性 <strong>系名</strong> 对码（学号，课名）的部分函数依赖。<br>对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 <strong>系主任</strong> 对码（学号，课名）的部分函数依赖。所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。</p><h3 id="部分函数依赖-1"><a href="#部分函数依赖-1" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>为了让表3符合2NF的要求，我们必须消除这些<strong>部分函数依赖</strong>，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”<strong>模式分解</strong>“。<br>模式分解的方法不是唯一的，以下是其中一种方法：<br><strong>选课（学号，课名，分数）</strong><br><strong>学生（学号，姓名，系名，系主任）</strong><br>我们先来判断以下，选课表与学生表，是否符合了2NF的要求？<br>   对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。<br>   对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。<br>图5表示了模式分解以后的新的函数依赖关系<br><img src="https://img-blog.csdnimg.cn/20181220144112622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="图5"><br>下图，表示了模式分解以后新的数据：<br><img src="https://img-blog.csdnimg.cn/20181220144157364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了）</p><p><strong>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</strong></p><ol><li>李小明转系到法律系只需要修改一次李小明对应的系的值即可。——有改进</li><li>数据冗余是否减少了？学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li><li>删除某个系中所有的学生记录该系的信息仍然全部丢失。——无改进</li><li>插入一个尚无学生的新系的信息。因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li></ol><p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性系主任对于码学号的<strong>传递函数依赖</strong>。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。</p><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><h2 id="3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。"><a href="#3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。" class="headerlink" title="3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。"></a>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</h2><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖，也就是说， <strong>如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求</strong>。接下来我们看看表4中的设计，是否符合3NF的要求。<br> 对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在<strong>非主属性系主任对于码学号的传递函数依赖</strong>，所以学生表的设计，不符合3NF的要求。<br> 为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：<br> <strong>选课（学号，课名，分数）<br> 学生（学号，姓名，系名）<br> 系（系名，系主任）</strong><br> 对于选课表，符合3NF的要求，之前已经分析过了。<br> 对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。<br> 对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。<br><strong>新的依赖关系如图：</strong><br><img src="https://img-blog.csdnimg.cn/20181220144621632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>新的数据如表：</strong><br><img src="https://img-blog.csdnimg.cn/20181220144644734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p><ol><li>删除某个系中所有的学生记录，该系的信息不会丢失。——有改进</li><li>插入一个尚无学生的新系的信息， 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li><li>数据冗余更加少了。——有改进</li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。</p><h1 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h1><h3 id="BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖"><a href="#BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖" class="headerlink" title="BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖"></a>BCNF范式不存在主属性对于码的<strong>部分函数依赖与传递函数依赖</strong></h3><p>要了解 BCNF 范式，那么先看这样一个问题：<br>若：某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？<br>答：<br><strong>函数依赖集：</strong>仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br><strong>码：</strong>（管理员，物品名），（仓库名，物品名）<br><strong>主属性：</strong>仓库名、管理员、物品名<br><strong>非主属性：</strong>数量<br><strong>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</strong><br>基于此关系模式的关系（具体的数据）可能如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20181220145111296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢</strong>？<br>我们来看以下几种操作：<br><strong>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？</strong><br>——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。<br><strong>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？</strong><br>——仓库本身与管理员的信息也被随之删除了。<br><strong>如果某仓库更换了管理员，会带来什么问题？</strong><br>——这个仓库有几条物品存放记录，就要修改多少次管理员信息。<br><strong>从这里我们可以得出结论：</strong><br>在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。<br><strong>造成此问题的原因：</strong><br>存在着主属性对于码的<strong>部分函数依赖与传递函数依赖</strong>。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖：<br>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）<br>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。<br>以上就是关于 BCNF 的解释。</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
