<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/12/23/%E5%B8%B8%E7%94%A8%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
      <url>/2018/12/23/%E5%B8%B8%E7%94%A8%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>常用画图工具推荐</p><p>平时学习的很多知识点，需要画图才能加强记忆，通过咨询大佬，总结几款比较好用的画图软件，希望能给大家提供些帮助。</p><p>1、lucidchart</p><p>2、draw.io</p><p>3、processon</p><p>4、sketch</p><p>5、画草图: <a href="https://www.autodraw.com/" target="_blank" rel="noopener">https://www.autodraw.com/</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/2018/12/23/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
      <url>/2018/12/23/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>JVM知识点梳理</p><p>我复习java虚拟机用的是 周志明老师的《深入理解java虚拟机》这本书，同时结合极客时间上 郑雨迪老师讲的《深入拆解java虚拟机》。将重点知识在此进行梳理，方便日后回顾复习。</p><p>本文部分图片和内容来源于<a href="https://cyc2018.gitbooks.io/interview-notebook/content/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html" target="_blank" rel="noopener">CyC2018博客</a></p><ul><li><h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><ul><li><h4 id="运行时数据区域："><a href="#运行时数据区域：" class="headerlink" title="运行时数据区域："></a>运行时数据区域：</h4><p><img src="https://img.mubu.com/document_image/154174f0-dab7-41b2-89bf-b8cc2da80f37-2160256.jpg" alt="img"></p></li><li><h4 id="程序计数器：-线程隔离，线程私有）"><a href="#程序计数器：-线程隔离，线程私有）" class="headerlink" title="程序计数器：(线程隔离，线程私有）"></a>程序计数器：(线程隔离，线程私有）</h4><p>可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。在任何一个确定的时刻，一个处理器（对于多处理器来说是一个内核）都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p></li><li><h4 id="java虚拟机栈：-线程私有）"><a href="#java虚拟机栈：-线程私有）" class="headerlink" title="java虚拟机栈：(线程私有）"></a>java虚拟机栈：(线程私有）</h4><p>生命周期与线程相同，虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储 局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p><img src="https://img.mubu.com/document_image/cbf98739-54fc-4479-a8f9-18515bf1174f-2160256.jpg" alt="img"></p><ul><li><h5 id="局部变量表："><a href="#局部变量表：" class="headerlink" title="局部变量表："></a>局部变量表：</h5><p>存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）局部变量表所需内存空间在编译期间完成分配。</p></li></ul></li><li><h4 id="本地方法栈：-线程私有）"><a href="#本地方法栈：-线程私有）" class="headerlink" title="本地方法栈：(线程私有）"></a>本地方法栈：(线程私有）</h4><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。它与虚拟机栈发挥的作用相似，他们之间的区别是：虚拟机栈为虚拟机执行java方法，本地方法栈为虚拟机使用到的native方法服务。</p><p><img src="https://img.mubu.com/document_image/6f530c3a-d740-47c8-b31a-cb434bb569b8-2160256.jpg" alt="img"></p></li><li><h4 id="java堆：-线程共享）"><a href="#java堆：-线程共享）" class="headerlink" title="java堆：(线程共享）"></a>java堆：(线程共享）</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，针对不同类型的对象采取不同的垃圾回收算法，可以将堆分成两块：</p><ul><li><h5 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h5><ul><li>Eden（伊甸园）</li><li>From Survivor（幸存者）</li><li>To Survivor</li></ul></li><li><h5 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h5><p>堆不需要连续内存，并且可以动态增加其内存，<strong>增加失败会抛出 OutOfMemoryError 异常</strong>。</p></li></ul></li><li><h4 id="方法区：-线程共享）"><a href="#方法区：-线程共享）" class="headerlink" title="方法区：(线程共享）"></a>方法区：(线程共享）</h4><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><ul><li>和堆一样不需要连续的内存，并且可以动态扩展，<strong>动态扩展失败一样会抛出 OutOfMemoryError 异常。</strong>对这块区域进行垃圾回收的主要目标是<strong>对常量池的回收和对类的卸载</strong>，但是一般比较难实现。JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是从 JDK 1.7 开始，已经把原本放在永久代的字符串常量池移到 Native Method 中。</li><li>运行时常量池：<strong>是方法区的一部分</strong>，Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。</li></ul></li><li><h4 id="直接内存："><a href="#直接内存：" class="headerlink" title="直接内存："></a>直接内存：</h4><p>并不是虚拟机运行时数据区一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。</p><ul><li>在 JDK 1.4 中新加入了 <strong>NIO 类</strong>，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <strong>DirectByteBuffer 对象</strong>作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</li></ul></li><li><h4 id="对象的创建流程图："><a href="#对象的创建流程图：" class="headerlink" title="对象的创建流程图："></a>对象的创建流程图：</h4><p><img src="https://img.mubu.com/document_image/d5eaebc5-a8dd-41fb-b4c6-6c47c9396e0a-2160256.jpg" alt="img"></p><ul><li><h5 id="以上在堆中为新生对象分配内存的方式有2种"><a href="#以上在堆中为新生对象分配内存的方式有2种" class="headerlink" title="以上在堆中为新生对象分配内存的方式有2种:"></a>以上在堆中为新生对象分配内存的方式有2种:</h5><ul><li><strong>指针碰撞：</strong>假设java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的放一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。在使用<strong>Serial、ParNew等带Compact过程的收集器时</strong>，系统使用的分配算法是指针碰撞。</li><li><strong>空闲列表：</strong>若java堆内存不是规整的，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。而<strong>使用CMS这种基于Mark-Sweep算法的收集器时</strong>，通常使用空闲列表。</li></ul></li></ul></li></ul></li><li><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>​     垃圾收集主要是针对<strong>堆和方法区</strong>进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p><ul><li><h4 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h4><ul><li><h5 id="引用计数算法："><a href="#引用计数算法：" class="headerlink" title="引用计数算法："></a>引用计数算法：</h5><ul><li>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</li><li>问题：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</li></ul></li><li><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><ul><li><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p><img src="https://img.mubu.com/document_image/8d087a34-a0c3-426c-b020-450fd4804805-2160256.jpg" alt="img"></p></li><li><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul></li></ul></li><li><h5 id="方法区的回收："><a href="#方法区的回收：" class="headerlink" title="方法区的回收："></a>方法区的回收：</h5><ul><li>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</li><li>主要是对常量池的回收和对类的卸载。</li><li>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</li><li>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：<ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul></li></ul></li><li><h5 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h5><ul><li>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</li><li>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</li></ul></li></ul></li></ul></li><li><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>被软引用关联的对象<strong>只有在内存不够的情况下才会被回收</strong>。</p><p>使用 <strong>SoftReference 类</strong>来创建软引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使对象只被软引用关联</span></code></pre></li><li><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到<strong>下一次垃圾回收发生之前</strong>。</p><p>使用 <strong>WeakReference</strong> 类来实现弱引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li><li><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 <strong>PhantomReference</strong> 来实现虚引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><p>## </p></li></ul></li><li><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><p>将存活的对象进行标记，然后清理掉未被标记的对象。</p></li></ul></li></ul><p>  <img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="img"></p><h5 id="不足："><a href="#不足：" class="headerlink" title="不足："></a><strong>不足</strong>：</h5><ol><li><p>标记和清除过程效率都不高。</p></li><li><p>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</p></li></ol><ul><li><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h4><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="img"></p></li></ul><ul><li><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="img"></p><ul><li><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p></li><li><p>主要不足是只使用了内存的一半。</p></li><li><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p></li><li><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p></li></ul></li><li><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul><li>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</li><li>一般将堆分为新生代和老年代：<ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除   /    标记 - 整理 算法</li></ul></li></ul></li></ul><ul><li><h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></li></ul><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="img"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><p>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</p><p>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p><ul><li><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="img"></p><ul><li>Serial 翻译为串行，也就是说它以串行的方式执行。</li><li>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</li><li>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</li><li>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</li></ul></li><li><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="img"></p><ul><li>它是 Serial 收集器的多线程版本。</li><li>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</li><li>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</li></ul></li><li><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><ul><li>与 ParNew 一样是多线程收集器。</li><li>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</li><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li><li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</li><li>可以通过一个开关参数打卡 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 。</li></ul></li><li><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="img"></p><ul><li>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</li><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul></li><li><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="img"></p><ul><li>是 Parallel Scavenge 收集器的老年代版本。</li><li>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</li></ul></li><li><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="img"></p><ul><li>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</li><li>分为以下四个流程：</li><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li><li>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</li><li>具有以下缺点：</li><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul></li><li><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><ul><li><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p></li><li><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img"></p></li><li><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img"></p></li><li><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p></li><li><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="img"></p></li><li><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p></li><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</p></li><li><p>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p></li><li><p>具备如下特点：</p></li><li><p>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p></li><li><p>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/23/hello-world/"/>
      <url>/2018/12/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>java高并发程序设计知识总结</title>
      <link href="/2018/12/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>最近把《实战java高并发程序设计》一书看了两遍，很多知识不加积累很快就忘记了，在此对java高并发这块知识进行总结，一方面自己回顾方法，另一方面可以给大家提供方便。</p><ul><li><h4 id="线程的母亲——进程"><a href="#线程的母亲——进程" class="headerlink" title="线程的母亲——进程"></a>线程的母亲——进程</h4><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li></ul></li><li><h4 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h4><ul><li>同步（Synchronous）和异步(Asynchronous)：同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的工作。</li><li>并发(Concurrency)和并行(Parallelism)：并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。</li><li>临界区：用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。在并行程序中，临界区资源是保护的对象。</li><li>阻塞（Blocking）和非阻塞(Non-Blocking)：他们用来形容多线程间的相互影响。如一个线程占用了临界区资源，那么其他所有需要这个资源的线程都必须等待，导致线程挂起，即阻塞。资源不释放，所有阻塞在临界区上的线程都不能工作。非阻塞与之相反，它指没有一个线程可以妨碍其他线程的执行。</li><li>死锁（DeadLock）：多个线程彼此占用了其他线程所需要的资源，得不到需要的资源，又不释放已得到的资源。</li><li>饥饿（Starvation）：指某一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。（如线程的优先级太低）还有一种情况，某一个线程一直占着资源不释放，导致其他需要这个资源的线程无法正常执行，与死锁相比，饥饿是有可能在未来一段时间内解决的。</li><li>活锁（LiveLock）：两个线程间，秉承“谦让”的原则，主动将资源释放给他人使用，可能会出现资源在两个线程中跳动，没有一个线程可以同时拿到所有资源而正常执行。</li></ul></li><li><h4 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h4><ul><li>阻塞（Blocking）：一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。使用synchronized关键字和ReentrantLock（重入锁）得到的就是阻塞线程。阻塞的控制方式是悲观策略。</li><li>无饥饿（Starvation-Free）：如果锁是公平的，满足先来后到，那饥饿就不会产生。</li><li>无障碍（Obstruction-Free）：无障碍是一种最弱的非阻塞调度。两个线程是无障碍地执行，那它们不会因为临界区的问题导致一方挂起，大家都可以大摇大摆地进入临界区。如果两个线程一起修改数据导致数据改坏了，则进行回滚， 保证数据安全。若没有数据竞争，则线程顺利完成工作，走出临界区。非阻塞的调度是一种乐观的策略。一种可行的无障碍实现可以依赖一个“一致性标记”来实现。</li><li>无锁（Lock-Free）：无锁的并行都是无障碍的。无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。如CAS操作。</li><li>无等待（Wait-Free）：它要求所有线程都必须在有限步内完成，这样就不会引起饥饿问题。</li></ul></li><li><h4 id="为什么要使用并行"><a href="#为什么要使用并行" class="headerlink" title="为什么要使用并行"></a>为什么要使用并行</h4><ul><li>为了获得更好的性能。</li><li>由于业务模型的需要，确实需要多个执行实体。</li></ul></li><li><h4 id="有关并行的两个重要定律"><a href="#有关并行的两个重要定律" class="headerlink" title="有关并行的两个重要定律"></a>有关并行的两个重要定律</h4><ul><li>Amdahl定律：加速比定义：加速比=优化前系统耗时/优化后系统耗时。 Amdahl定律强调，当串行比例一定时，加速比是有上限的，不管你堆叠多少CPU参与计算，都不能突破这个上限！</li><li>Gustafson定律：其关心的是：如果可被并行化的代码所占比重足够多，那么加速比就可以随着CPU的数量线性增长。</li></ul></li><li><h4 id="java内存模型（JMM）"><a href="#java内存模型（JMM）" class="headerlink" title="java内存模型（JMM）"></a>java内存模型（JMM）</h4><ul><li>原子性（Atomicity）: 原子性指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。对于32系统来说，Long类型的数据的读写不是原子性的（long有64位）。</li><li>可见性（Visibility）: 可见性是指当一个线程修改了某一个共享变量，其他线程是否能够立即知道这个修改。</li><li>有序性（Ordering）：单线程环境下，指令从前往后执行；多线程环境下，可能会进行指令重排，重排后的指令与原指令顺序未必一致。指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。</li></ul></li><li><h4 id="Happen-Before原则"><a href="#Happen-Before原则" class="headerlink" title="Happen-Before原则"></a>Happen-Before原则</h4><ul><li>程序顺序原则：一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性。</li><li>锁规则：解锁必然发生在随后的加锁前。</li><li>传递性：A先于B，B先于C，那么A必然先于C</li><li>线程的start()方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结（Thread.join()）</li><li>线程的中断（interrupt（））先于被中断线程的代码</li><li>对象的构造函数执行、结束先于finalize()方法</li></ul></li><li><h3 id="java并行程序基础"><a href="#java并行程序基础" class="headerlink" title="java并行程序基础"></a>java并行程序基础</h3><ul><li><h4 id="线程状态转换："><a href="#线程状态转换：" class="headerlink" title="线程状态转换："></a>线程状态转换：</h4><p><img src="https://img.mubu.com/document_image/e1375cab-d57b-44a2-9a35-aed41db90124-2160256.jpg" alt="img"></p><ul><li>新建（New）：创建后尚未启动。</li><li>可运行（Runnable）：可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态中的 Running 和 Ready。</li><li>阻塞（Blocking）: 等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li><li>无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</li><li>限期等待（Timed Waiting）无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</li><li>死亡（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束。</li></ul></li><li><h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h4><ul><li>实现Runnable接口</li><li>实现Callable接口</li><li>继承Thread类</li><li>说明：实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</li><li>三种实现方式的比较：<ul><li>实现Runnable接口可以避免Java单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。</li><li>继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法。</li><li>实现Callable接又要实现call方法，并且线程执行完毕后会有返回值。其他的两种都是重写run方法，没有返回值。</li><li>实现接口会更好一些，因为：①Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；②类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul></li></ul></li><li><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><ul><li>Thread.stop()方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。若此时线程写入数据写到一半，并强行终止，那么对象就会被写坏，另一个线程读到不一致的对象。所以，不建议使用Thread.stop() 来终止线程</li><li>解决：可以定义一个标记变量 stopme, 用于指示线程是否需要退出，当调用线程终止方法（stopMe()）,stopme被设置为true,单线程执行到此，检测到改动，自然退出，不会使对象的状态出现错误。</li></ul></li><li><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><ul><li>Thread.interrupt() : 是实例方法，通知目标线程中断，即设置中断标志位。</li><li>Thread.isInterrupted() ：是实例方法，判断当前线程是否有被中断。</li><li>Thread.interrupted() ：静态方法，判断当前线程的中断状态，但同时会清除当前线程的中断标志位状态</li></ul></li><li><h4 id="等待（wait）和通知（notify）"><a href="#等待（wait）和通知（notify）" class="headerlink" title="等待（wait）和通知（notify）"></a>等待（wait）和通知（notify）</h4><ul><li>object.wait()：如果一个线程调用了object.wait()，那么它就会进入object 对象的等待队列，这个等待队列，可能会有多个线程同时等待某一个对象。</li><li>object.notify()：如果object.notify()被调用时，它就会从这个等待队列中，随机选择一个线程，并将其唤醒。（注意：这个选择是不公平，随机的）</li><li>说明：object.wait()不能随便调用，它必须包含在对应的synchronized语句中，无论是wait()或者notify()都需要首先获得目标对象的一个监视器</li><li>object.wait()和Thread.sleep() : 两个方法都可以让线程等待若干时间，除了wait()可以被唤醒外，另外一个主要的区别就是wait()方法会释放目标对象的锁，Tread.sleep()方法不会释放任何资源。</li></ul></li><li><h4 id="挂起（suspend）和继续执行（resume）线程"><a href="#挂起（suspend）和继续执行（resume）线程" class="headerlink" title="挂起（suspend）和继续执行（resume）线程"></a>挂起（suspend）和继续执行（resume）线程</h4><ul><li>suspend在导致线程暂停的同时，并不会去释放任何锁资源。此时，其他线程想要访问被它暂用的锁时，都会被牵连，导致无法正常继续运行。直到对应的线程上进行了resume()操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。所以不推荐使用suspend()去挂起线程</li><li>另外，如果resume()操作意外地在suspend()前就释放了，那么挂起的线程可能很难有机会继续执行。并且，更严重的是，它所占用的锁不会释放，因此可能导致整个系统工作不正常。（被挂起的线程，处于Runnable状态，让我们没办法对系统当前状态进行判断呀）</li></ul></li><li><h4 id="等待线程结束（join）和谦让（yield）"><a href="#等待线程结束（join）和谦让（yield）" class="headerlink" title="等待线程结束（join）和谦让（yield）"></a>等待线程结束（join）和谦让（yield）</h4><ul><li>join() 表示无限时等待，它会一直阻塞当前线程，直到目标线程执行完毕。join()的本质是让调用线程wait()在当前线程对象实例上。（调用线程等待当前线程）</li><li>join(long millis) 给出最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因“等不及了”，而继续往下执行。</li><li>Thread.yield()：是一个静态方法，一旦执行，会使当前线程让出CPU。但要注意，让出CPU并不表示当前线程不执行了，当前线程在让出CPU后，还会进行CPU资源的争夺，但能否再次分配到就不一定了。</li></ul></li><li><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><ul><li>当用volatile去声明一个变量的时候，就等于告诉了虚拟机，这个变量极有可能会被某些程序或者线程修改。</li><li>volatile能保证数据的可见性和有序性，不能保证原子性。</li></ul></li><li><h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><ul><li>ThreadGroup tg = new ThreadGroup(“ThreadGroup name”); 在创建线程和线程组的时候，给他们取一个好听的名字。</li></ul></li><li><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li>守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地完成一些系统性的服务，比如垃圾回收线程，JIT线程可以理解为守护线程。</li><li>当一个java应用内，只有守护线程时，java虚拟机就会自然退出。</li><li>t.setDaemon(true); 将一个线程设置为守护线程。</li></ul></li><li><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>在java中，使用1-10表示线程优先级，数字越大优先级越高</li><li>public final static int MIN_PRIORITY = 1;</li><li>public final static int NORM_PRIORITY = 5;</li><li>public final static int MAX_PRIORITY = 10;</li><li>thread.setPriority(Thread.MAX_PRIORITY ) // 为一个线程设置优先级</li></ul></li><li><h4 id="synchronized-的加锁方式"><a href="#synchronized-的加锁方式" class="headerlink" title="synchronized 的加锁方式"></a>synchronized 的加锁方式</h4><ul><li>同步一个代码块 ： 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</li><li>同步一个方法 ： 它和同步代码块一样，作用于同一个对象。</li><li>同步一个类： 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li><li>同步一个静态方法： 作用于整个类。</li></ul></li></ul></li><li><h3 id="JDK并发包："><a href="#JDK并发包：" class="headerlink" title="JDK并发包："></a>JDK并发包：</h3><ul><li><h4 id="同步控制："><a href="#同步控制：" class="headerlink" title="同步控制："></a>同步控制：</h4><ul><li><h5 id="ReentrantLock（重入锁-）"><a href="#ReentrantLock（重入锁-）" class="headerlink" title="ReentrantLock（重入锁 ）"></a>ReentrantLock（重入锁 ）</h5><ul><li>重入锁可以完全替代synchronized关键字，使用 java.util.concurrent.locks.ReentrantLock 类来实现。“重入”？：这种锁是可以反复进入的(这里的反复仅仅局限于一个线程),如果一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数的锁。</li><li>Synchronized与ReentrantLock比较：<ul><li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断: 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li></ul></li><li>lock.lock() 和 lock.lockInterruptibly()的区别：<ul><li>lock() 优先获得锁</li><li>lockInterruptibly() 优先相应中断</li></ul></li><li>锁申请等待限时 tryLock：<ul><li>lock.tryLock(5, TimeUnit.SECONDS) 参数表示等待时常， 计时单位</li><li>lock.tryLock(）不带参数时，申请锁成功立即返回true,申请失败，不会等待，立即返回false.</li></ul></li></ul></li><li><h5 id="Condition条件"><a href="#Condition条件" class="headerlink" title="Condition条件:"></a>Condition条件:</h5><ul><li>ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); //新建一个与lock绑定的condition对象</li><li>condition.await(); //让线程在Condition对象上等待，线程调用condition.await()时，要求线程持有相关的重入锁，在condition.await()调用之后，线程会释放这把锁</li><li>condition.signal(); //唤醒线程，condition.signal()方法调用时，也要求线程先获得相关的锁，在signal()方法调用之后，系统会从当前condition对象的等待队列中，唤醒一个线程。</li><li>ArrayBlockingQueue 的put()和take()方法使用的重入锁和Condition条件。</li></ul></li><li><h5 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）:"></a>信号量（Semaphore）:</h5><ul><li>信号量可以指定多个线程同时访问某个资源。</li><li>Semaphore semp = new Semaphore(5); //构造信号量对象，必须指定信号量准入数。</li><li>aquire() 方法尝试获得一个准入的许可。</li><li>acquireUninterruptibly() 不响应中断。</li><li>release() 用于在线程访问资源结束后，释放一个许可</li></ul></li><li><h5 id="读写锁（ReadWriteLock）："><a href="#读写锁（ReadWriteLock）：" class="headerlink" title="读写锁（ReadWriteLock）："></a>读写锁（ReadWriteLock）：</h5><ul><li>ReadWriteLock是jdk5中提供的读写分离锁，读写锁允许多个线程同时读，写写操作和读写操作间依然是需要相互等待和持有锁的。</li><li>ReentrantReadWriteLock readWritelock = new ReentrantReadWriteLock(); Lock readLock = readWritelock .readLock(); Lock writeLock = readWritelock .writeLock();</li></ul></li><li><h5 id="倒计时器-CountDownLatch"><a href="#倒计时器-CountDownLatch" class="headerlink" title="倒计时器(CountDownLatch):"></a>倒计时器(CountDownLatch):</h5><ul><li>控制线程等待，让某一线程等待直到倒计时结束，再开始执行。</li><li>CountDownLatch.countdown(); //通知CountDownLatch 一个线程已经完成，倒计时器可以减1了。</li><li>CountDownLatch.await(); //主线等待所有任务全部完成再往下执行</li></ul></li><li><h5 id="循环栅栏（CyclicBarrier）"><a href="#循环栅栏（CyclicBarrier）" class="headerlink" title="循环栅栏（CyclicBarrier）:"></a>循环栅栏（CyclicBarrier）:</h5><ul><li>和CountDownLatch非常类似，但功能更加复杂且强大</li></ul></li><li><h5 id="线程阻塞工具类（LockSupport）"><a href="#线程阻塞工具类（LockSupport）" class="headerlink" title="线程阻塞工具类（LockSupport）:"></a>线程阻塞工具类（LockSupport）:</h5><ul><li>它可以在线程内任意位置让线程阻塞，和Thread.suspend()相比，它弥补了由于resume() 在前发生，导致线程无法继续执行的情况。</li><li>LockSupport.park()；//挂起线程 LockSupport.unpark() //让线程继续执行。</li><li>LockSupport 类使用类似信号量的机制，它为每一个线程准备了一个许可，如果许可可用，那么park()函数会立即返回，并且消费这个许可（即将许可变为不可用），如果许可不可用，就会阻塞，而unpark()则是使一个许可变为可用（但是和信号量不同的是，许可不能累加，你不可能拥有超过一个许可，他永远只有一个）。即使unpack() 操作发生在pack() 之前，它也可以使下一次的park() 操作立即返回。</li><li>park() 挂起状态的线程，会非常明确地给出一个WAITING状态，甚至还会标注是park() 引起的。</li></ul></li></ul></li><li><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4></li><li><h4 id="JDK的并发容器"><a href="#JDK的并发容器" class="headerlink" title="JDK的并发容器"></a>JDK的并发容器</h4><ul><li><p>ConcurrentHashMap：位于java.util.concurrent 包内，是线程安全的HashMap</p></li><li><p>CopyOnWriteArrayList:</p></li><li><p>ConcurrentLinkedQueue:</p></li><li><p>BlockingQueue:</p></li><li><h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap:"></a>ConcurrentSkipListMap:</h3></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>剑指Offer-48 ：最长不含重复字符的子字符串</title>
      <link href="/2018/12/21/%E5%89%91%E6%8C%87Offer-%E9%A2%9848%20%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/21/%E5%89%91%E6%8C%87Offer-%E9%A2%9848%20%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：最长不含重复字符的子字符串"><a href="#题目：最长不含重复字符的子字符串" class="headerlink" title="题目：最长不含重复字符的子字符串"></a>题目：最长不含重复字符的子字符串</h3><p>​      请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p><p><strong>主要思路：</strong></p><p>使用动态规划，记录当前字符之前的最长非重复子字符串长度f(i-1)，其中i为当前字符的位置。每次遍历当前字符时，分两种情况进行讨论：</p><ol><li>若当前字符第一次出现，则最长非重复子字符串长度f(i) = f(i-1)+1。 </li><li>若当前字符不是第一次出现，则首先计算当前字符与它上次出现位置之间的距离d。<br>若d大于f(i-1)，即说明前一个非重复子字符串中没有包含当前字符，则可以添加当前字符到前一个非重复子字符串中，所以，f(i) = f(i-1)+1。<br>若d小于或等于f(i-1)，即说明前一个非重复子字符串中已经包含当前字符，则不可以添加当前字符，所以，f(i) = d。</li></ol><p><strong>java代码实现：</strong></p><hr><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> offer<span class="token punctuation">.</span>coder<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TheMaxNoRepeatString48</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//测试代码</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMaxNoRepeatString</span><span class="token punctuation">(</span><span class="token string">"abaacdwq"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMaxNoRepeatString</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> position <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化位置数组position</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> position<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            position<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 定位元素在数组中的下标 </span>            <span class="token keyword">int</span> index <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 上一个元素出现的位置</span>            <span class="token keyword">int</span> prePosition <span class="token operator">=</span> position<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算此次出现距上次出现的距离</span>            <span class="token keyword">int</span> distance <span class="token operator">=</span> i <span class="token operator">-</span> prePosition<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//距离 > 当前长度 ; 忽略，长度+1，继续判断下一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>prePosition <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> distance <span class="token operator">></span> curLength<span class="token punctuation">)</span><span class="token punctuation">{</span>                  curLength<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                curLength <span class="token operator">=</span> distance<span class="token punctuation">;</span>                maxLength <span class="token operator">=</span> maxLength <span class="token operator">></span> curLength <span class="token operator">?</span> maxLength <span class="token operator">:</span> curLength<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                position<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxLength <span class="token operator">></span> curLength <span class="token operator">?</span> maxLength <span class="token operator">:</span> curLength<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如何解释关系数据库的第一第二第三范式？</title>
      <link href="/2018/12/20/%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F/"/>
      <url>/2018/12/20/%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。</p><h6 id="本文转自知乎刘慰教师"><a href="#本文转自知乎刘慰教师" class="headerlink" title="本文转自知乎刘慰教师"></a>本文转自知乎<a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">刘慰教师</a></h6><h1 id="范式介绍"><a href="#范式介绍" class="headerlink" title="范式介绍"></a>范式介绍</h1><p>   首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><h2 id="1NF的定义为：符合1NF的关系中的每个属性都不可再分。"><a href="#1NF的定义为：符合1NF的关系中的每个属性都不可再分。" class="headerlink" title="1NF的定义为：符合1NF的关系中的每个属性都不可再分。"></a>1NF的定义为：符合1NF的关系中的每个属性都不可再分。</h2><p>符合1NF的关系（你可以理解为数据表。“关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。<br>表1所示的情况，就不符合1NF的要求：</p><p><img src="https://img-blog.csdnimg.cn/20181220111349147.png" alt="表1"></p><p>实际上，<strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，<strong>只要在RDBMS中已经存在的数据表，一定是符合1NF的</strong>。<br>如果我们要在RDBMS中表现表中的数据，就得设计为表2的形式：</p><p> <img src="https://img-blog.csdnimg.cn/20181220111517383.png" alt="表2"><br>但是仅仅符合1NF的设计，仍然会存在<strong>数据冗余过大，插入异常，删除异常，修改异常</strong>的问题，例如对于表3中的设计：<br><img src="https://img-blog.csdnimg.cn/20181220111559788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="表3"></p><ol><li>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——<strong>数据冗余过大</strong></li><li>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 ——<strong>插入异常</strong><br>根据三种关系完整性约束中实体完整性的要求，关系中的<strong>码</strong>所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将<strong>学号与课名的组合</strong>作为码，否则就无法唯一地区分每一条记录。[<strong>码</strong>：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）]。</li><li>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong></li><li><p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。<br>正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。</p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><h2 id="2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。"><a href="#2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。" class="headerlink" title="2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。"></a>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。</h2><p>第二范式（2NF）在关系理论中的严格定义我这里就不多介绍了（因为涉及到的铺垫比较多），只需要了解2NF对1NF进行了哪些改进即可。其改进是，2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。接下来对这句话中涉及到的四个概念———<strong>“函数依赖”、“码”、“非主属性”、与“部分函数依赖” </strong>进行一下解释。</p></li></ol><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>我们可以这么理解（但并不是特别严格的定义）：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说<strong>Y函数依赖于X，写作 X → Y</strong>。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也  就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。</p><p>例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说<strong>姓名函数依赖于学号，写作 学号 → 姓名</strong>。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。</p><p> <strong>表中,其他的函数依赖关系还有如：</strong></p><ul><li>系名 → 系主任</li><li>学号 → 系主任</li><li><p>（学号，课名） → 分数</p><p><strong>但以下函数依赖关系则不成立：</strong></p></li><li>学号 → 课名</li><li>学号 → 分数</li><li>课名 → 系主任</li><li>（学号，课名）→ 姓名<br>从“函数依赖”这个概念展开，还会有三个概念：<h5 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h5>在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ‘ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作：<br><img src="https://img-blog.csdnimg.cn/20181220113000872.png" alt="无"><br>例如： 学号 F→ 姓名 （学号，课名） F→ 分数  （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）</li></ul><h5 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h5><p>假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 ：<br><img src="https://img-blog.csdnimg.cn/20181220113146810.png" alt="在这里插入图片描述"><br>例如：（学号，课名） P→ 姓名</p><h5 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h5><p>假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （基于『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作：<br><img src="https://img-blog.csdnimg.cn/20181220141747431.png" alt="在这里插入图片描述"></p><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都<strong>完全函数依赖</strong>于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。<br>在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。<br>一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为<strong>主码</strong>）<br>例如：对于表3，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）</p><h3 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h3><p>包含在任何一个码中的属性成为主属性。<br>例如：<br>对于表3，主属性就有两个，学号 与 课名。</p><p>终于可以回过来看2NF了。<br>首先，我们需要判断，表3是否符合2NF的要求？<br>根据2NF的定义，判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。<br><strong>判断的方法是：</strong><br>第一步：找出数据表中所有的码。<br>第二步：根据第一步所得到的码，找出所有的主属性。<br>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<br>第四步：查看是否存在非主属性对码的部分函数依赖。<br>对于表3，根据前面所说的四步，<strong>我们可以这么做</strong>：<br>第一步：查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。……查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“完全函数依赖”）。<br>图4表示了表中所有的函数依赖关系：<br><img src="https://img-blog.csdnimg.cn/20181220143506956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="图4"></p><p>这一步完成以后，可以得到，表3的码只有一个，就是（学号、课名）。<br>第二步：主属性有两个：学号 与 课名<br>第三步：非主属性有四个：姓名、系名、系主任、分数<br>第四步：对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 <strong>姓名</strong> 对码（学号，课名）的部分函数依赖。<br>对于（学号，课名）→ 系名，有 学号 → 系名，存在非主属性 <strong>系名</strong> 对码（学号，课名）的部分函数依赖。<br>对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 <strong>系主任</strong> 对码（学号，课名）的部分函数依赖。所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。</p><h3 id="部分函数依赖-1"><a href="#部分函数依赖-1" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>为了让表3符合2NF的要求，我们必须消除这些<strong>部分函数依赖</strong>，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”<strong>模式分解</strong>“。<br>模式分解的方法不是唯一的，以下是其中一种方法：<br><strong>选课（学号，课名，分数）</strong><br><strong>学生（学号，姓名，系名，系主任）</strong><br>我们先来判断以下，选课表与学生表，是否符合了2NF的要求？<br>   对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。<br>   对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。<br>图5表示了模式分解以后的新的函数依赖关系<br><img src="https://img-blog.csdnimg.cn/20181220144112622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="图5"><br>下图，表示了模式分解以后新的数据：<br><img src="https://img-blog.csdnimg.cn/20181220144157364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了）</p><p><strong>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</strong></p><ol><li>李小明转系到法律系只需要修改一次李小明对应的系的值即可。——有改进</li><li>数据冗余是否减少了？学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li><li>删除某个系中所有的学生记录该系的信息仍然全部丢失。——无改进</li><li>插入一个尚无学生的新系的信息。因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li></ol><p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性系主任对于码学号的<strong>传递函数依赖</strong>。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。</p><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><h2 id="3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。"><a href="#3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。" class="headerlink" title="3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。"></a>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</h2><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖，也就是说， <strong>如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求</strong>。接下来我们看看表4中的设计，是否符合3NF的要求。<br> 对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在<strong>非主属性系主任对于码学号的传递函数依赖</strong>，所以学生表的设计，不符合3NF的要求。<br> 为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：<br> <strong>选课（学号，课名，分数）<br> 学生（学号，姓名，系名）<br> 系（系名，系主任）</strong><br> 对于选课表，符合3NF的要求，之前已经分析过了。<br> 对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。<br> 对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。<br><strong>新的依赖关系如图：</strong><br><img src="https://img-blog.csdnimg.cn/20181220144621632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>新的数据如表：</strong><br><img src="https://img-blog.csdnimg.cn/20181220144644734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p><ol><li>删除某个系中所有的学生记录，该系的信息不会丢失。——有改进</li><li>插入一个尚无学生的新系的信息， 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li><li>数据冗余更加少了。——有改进</li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。</p><h1 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h1><h3 id="BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖"><a href="#BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖" class="headerlink" title="BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖"></a>BCNF范式不存在主属性对于码的<strong>部分函数依赖与传递函数依赖</strong></h3><p>要了解 BCNF 范式，那么先看这样一个问题：<br>若：某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？<br>答：<br><strong>函数依赖集：</strong>仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br><strong>码：</strong>（管理员，物品名），（仓库名，物品名）<br><strong>主属性：</strong>仓库名、管理员、物品名<br><strong>非主属性：</strong>数量<br><strong>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</strong><br>基于此关系模式的关系（具体的数据）可能如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20181220145111296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢</strong>？<br>我们来看以下几种操作：<br><strong>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？</strong><br>——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。<br><strong>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？</strong><br>——仓库本身与管理员的信息也被随之删除了。<br><strong>如果某仓库更换了管理员，会带来什么问题？</strong><br>——这个仓库有几条物品存放记录，就要修改多少次管理员信息。<br><strong>从这里我们可以得出结论：</strong><br>在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。<br><strong>造成此问题的原因：</strong><br>存在着主属性对于码的<strong>部分函数依赖与传递函数依赖</strong>。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖：<br>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）<br>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。<br>以上就是关于 BCNF 的解释。</p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
