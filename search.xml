<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>剑指offer:数组中数字出现的次数</title>
      <link href="/2018/12/26/%E5%89%91%E6%8C%87offer%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
      <url>/2018/12/26/%E5%89%91%E6%8C%87offer%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写出程序找出这个两个出现一次的数字，要求时间复杂度O(n)，空间复杂度O(1)。</p><p><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&amp;tqId=11193&amp;tPage=2&amp;rp=2&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking" target="_blank" rel="noopener">牛客网链接</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>看到这个题目，我首先想到遍历数组，用HashMap存放每个数组出现的次数，K为元素值，V为该元素出现的次数。并迅速用代码实现，并在牛客上通过了。</p><p>但仔细一看，该题目并没有这么简单，要求时间复杂度O(n),使用HashMap能满足，但是空间复杂度要求O(1)，这个要求明显不满足，我们的是O(n).</p><p>新的思路：基于以下技术点</p><ol><li>两个相同的数字的异或结果是0</li><li>任意数字异或0结果还是该数字</li><li>任意数字与1结果还是该数字</li></ol><p>我们将该数组中的数组进行异或，得到的结果是两个出现一次的数组异或的结果。因为其他数字都出现了两次，在异或中抵消了。这两个数字不同，所以异或结果不为0，也就是至少有一位是1。</p><p>我们在结果数字中找到第一个为1的位的位置，记为第n位。</p><p>现在我们以第n位是不是1为标准把原数组中的数组分成两个子数组，并分别进行异或操作，两个子数组异或的结果就是这两个出现一次的数。</p><h3 id="代码实现（java）"><a href="#代码实现（java）" class="headerlink" title="代码实现（java）"></a>代码实现（java）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//num1,num2分别为长度为1的数组。传出参数</span><span class="token comment" spellcheck="true">//将num1[0],num2[0]设置为返回结果</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">FindNumsAppearOnce</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> num1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> each <span class="token operator">:</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">^=</span> each<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//找到异或结果中第一个为1的位的位置</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>result<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result <span class="token operator">=</span> result<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        num1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        num2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> each <span class="token operator">:</span> array<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isBit</span><span class="token punctuation">(</span>each<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                num1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">^=</span>each<span class="token punctuation">;</span>            <span class="token keyword">else</span>                num2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">^=</span>each<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">isBit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>        num <span class="token operator">=</span> num<span class="token operator">>></span>index<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>num<span class="token operator">&amp;</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>先序、中序、后序遍历二叉树</title>
      <link href="/2018/12/24/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/12/24/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>先序、中序、后序遍历二叉树是一个基础又非常重要的知识点，频繁出现在《剑指offer》面试题中，很多题目都是二叉树遍历的变形。</p><p>所以在本文章中，我总结了用递归和非递归的方法分别实现对二叉树的先序、中序和后序遍历。</p><p>面试题54：二叉搜索树</p><ul><li><h3 id="递归实现三种遍历"><a href="#递归实现三种遍历" class="headerlink" title="递归实现三种遍历"></a>递归实现三种遍历</h3><ul><li><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> algorithm<span class="token punctuation">.</span>tree<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** *  * @author FHY * 递归实现 * 按照先序遍历树的顺序打印树结点 */</span><span class="token comment" spellcheck="true">/* * 树节点定义 */</span><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    TreeNode left<span class="token punctuation">;</span>    TreeNode right<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* 二叉树结构如下：* *        0*      /   \*     1     2*    / \   / \*   3   4 5   6*  * 先序遍历结果：0 1 3 4 2 5 6*/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PreOrderTraversal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printPreOrderTreeNode</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printPreOrderTreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printPreOrderTreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> node1<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">;</span>        node1<span class="token punctuation">.</span>left <span class="token operator">=</span> node3<span class="token punctuation">;</span>        node1<span class="token punctuation">.</span>right <span class="token operator">=</span> node4<span class="token punctuation">;</span>        node2<span class="token punctuation">.</span>left <span class="token operator">=</span> node5<span class="token punctuation">;</span>        node2<span class="token punctuation">.</span>right <span class="token operator">=</span> node6<span class="token punctuation">;</span>        <span class="token function">printPreOrderTreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre></li><li><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> algorithm<span class="token punctuation">.</span>tree<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** *  * @author FHY * 递归实现 * 按照中序遍历树节点的顺序打印树节点 */</span><span class="token comment" spellcheck="true">/* 新建二叉树如下：* *        0*      /   \*     1     2*    / \   / \*   3   4 5   6*   * 中序遍历结果：3 1 4 0 5 2 6*/</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InOrderTraversal_1</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printInOrderTreeNode</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">printInOrderTreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">printInOrderTreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> node1<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">;</span>        node1<span class="token punctuation">.</span>left <span class="token operator">=</span> node3<span class="token punctuation">;</span>        node1<span class="token punctuation">.</span>right <span class="token operator">=</span> node4<span class="token punctuation">;</span>        node2<span class="token punctuation">.</span>left <span class="token operator">=</span> node5<span class="token punctuation">;</span>        node2<span class="token punctuation">.</span>right <span class="token operator">=</span> node6<span class="token punctuation">;</span>        <span class="token function">printInOrderTreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> algorithm<span class="token punctuation">.</span>tree<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** *  * @author FHY * 递归实现 * 按照后序遍历树节点的顺序打印树节点 */</span><span class="token comment" spellcheck="true">/* 新建二叉树如下： *  *        0 *      /   \ *     1     2 *    / \   / \ *   3   4 5   6 *    * 后序遍历结果：3 4 1 5 6 2 0 */</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PostOrderTraversal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode node6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span>left <span class="token operator">=</span> node1<span class="token punctuation">;</span>        root<span class="token punctuation">.</span>right <span class="token operator">=</span> node2<span class="token punctuation">;</span>        node1<span class="token punctuation">.</span>left <span class="token operator">=</span> node3<span class="token punctuation">;</span>        node1<span class="token punctuation">.</span>right <span class="token operator">=</span> node4<span class="token punctuation">;</span>        node2<span class="token punctuation">.</span>left <span class="token operator">=</span> node5<span class="token punctuation">;</span>        node2<span class="token punctuation">.</span>right <span class="token operator">=</span> node6<span class="token punctuation">;</span>        <span class="token function">postOrderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre></li></ul></li><li><h3 id="非递归实现三种遍历（待补）"><a href="#非递归实现三种遍历（待补）" class="headerlink" title="非递归实现三种遍历（待补）"></a>非递归实现三种遍历（待补）</h3><ul><li><h4 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h4></li><li><h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4></li><li><h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/12/24/hello-world/"/>
      <url>/2018/12/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题：用wait-notify 写一段代码来解决生产者-消费者问题</title>
      <link href="/2018/12/24/%E7%94%A8-wait-notify-%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/"/>
      <url>/2018/12/24/%E7%94%A8-wait-notify-%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="java使用-wait和notify实现生产者消费者模型"><a href="#java使用-wait和notify实现生产者消费者模型" class="headerlink" title="java使用 wait和notify实现生产者消费者模型"></a>java使用 wait和notify实现生产者消费者模型</h3><p>​       在多线程开发中，最经典的一个模型就是<strong>生产者消费者模型</strong>，他们有一个缓冲区，缓冲区有最大限制，当缓冲区满的时候，生产者是不能将产品放入到缓冲区里面的，当然，当缓冲区是空的时候，消费者也不能从中拿出来产品，这就涉及到了在多线程中的条件判断。</p><p>​    java为了实现这些功能，提供了<strong>wait和notify</strong>方法，他们可以在线程不满足要求的时候，让线程让出来资源等待（wait），当有资源的时候再唤醒(notify)他们让他们继续工作，下面我们用实际的代码（java）来展示如何使用wait和notify。</p><h3 id="首先是缓冲区实现，我们用LinkedList-来实现"><a href="#首先是缓冲区实现，我们用LinkedList-来实现" class="headerlink" title="首先是缓冲区实现，我们用LinkedList 来实现"></a>首先是缓冲区实现，我们用LinkedList 来实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> concurrency<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>waitAndNotify<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> maxSize<span class="token punctuation">;</span>    <span class="token keyword">private</span> LinkedList<span class="token operator">&lt;</span>Date<span class="token operator">></span> storage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        maxSize <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Date<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//往缓冲区插入一个元素</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> maxSize<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span><span class="token punctuation">{</span>                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        storage<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Set:"</span><span class="token operator">+</span>storage<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//从缓冲区取出一个元素</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>storage<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span><span class="token punctuation">{</span>                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Get: %d %s \n"</span><span class="token punctuation">,</span> storage<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> storage<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="生产者实现："><a href="#生产者实现：" class="headerlink" title="生产者实现："></a>生产者实现：</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> concurrency<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>waitAndNotify<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    Storage storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>Storage storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            storage<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="消费者实现："><a href="#消费者实现：" class="headerlink" title="消费者实现："></a>消费者实现：</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> concurrency<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>waitAndNotify<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    Storage storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>Storage storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            storage<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> concurrency<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>waitAndNotify2<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Storage storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Producer producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>producer<span class="token punctuation">)</span><span class="token punctuation">;</span>        Consumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最近5年133个Java面试问题列表</title>
      <link href="/2018/12/24/%E6%9C%80%E8%BF%915%E5%B9%B4133%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/"/>
      <url>/2018/12/24/%E6%9C%80%E8%BF%915%E5%B9%B4133%E4%B8%AAJava%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>本文转自知乎：<a href="https://zhuanlan.zhihu.com/p/23533393?utm_medium=social&amp;utm_member=ZjgxYjFkMTI4OWUwYzVmNWJhZWZmOGIxYWFiMDk0NGI%3D&amp;utm_source=wechat_timeline&amp;from=timeline&amp;isappinstalled=0&amp;wechatShare=1" target="_blank" rel="noopener">极乐科技</a></p><p>Java 面试随着时间的改变而改变。在过去的日子里，当你知道 String 和 StringBuilder 的区别（String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象。因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，影响性能，可以考虑使用可变字符序列StringBuilder）就能让你直接进入第二轮面试，但是现在问题变得越来越高级，面试官问的问题也更深入。 在我初入职场的时候，类似于 Vector 与 Array 的区别、HashMap 与 Hashtable 的区别是最流行的问题，只需要记住它们，就能在面试中获得更好的机会，但这种情形已经不复存在。如今，你将会被问到许多 Java 程序员都没有看过的领域，如 NIO，设计模式，成熟的单元测试，或者那些很难掌握的知识，如并发、算法、数据结构及编码。</p><p>由于我喜欢研究面试题，因此我已经收集了许多的面试问题，包括许多许多不同的主题。我已经为这众多的问题准备一段时间了，现在我将它们分享给你们。这里面不但包含经典的面试问题，如线程、集合、equals 和 hashcode、socket，而且还包含了 NIO、数组、字符串、Java 8 等主题。</p><p>该列表包含了入门级 Java 程序员和多年经验的高级开发者的问题。无论你是 1、2、3、4、5、6、7、8、9 还是 10 年经验的开发者，你都能在其中找到一些有趣的问题。这里包含了一些超级容易回答的问题，同时包含经验丰富的 Java 程序员也会棘手的问题。</p><p>当然你们也是非常幸运的，当今有许多好的书来帮助你准备 Java 面试，其中有一本我觉得特别有用和有趣的是 Markham 的 Java 程序面试揭秘（Java Programming Interview Exposed）。 这本书会告诉你一些 Java 和 JEE 面试中最重要的主题，即使你不是准备 Java 面试，也值得一读。</p><p>该问题列表特别长，我们有各个地方的问题，所以，答案必须要短小、简洁、干脆，不拖泥带水。因此，除了这一个段落，你只会听到问题与答案，再无其他内容，没有反馈，也没有评价。为此，我已经写好了一些博文，在这些文章中你可以找到我对某些问题的观点，如我为什么喜欢这个问题，这个问题的挑战是什么？期望从面试者那获取到什么样的答案？</p><p>这个列表有一点不同，我鼓励你采用类似的方式去分享问题和答案，这样容易温习。我希望这个列表对面试官和候选人都有很好的用处，面试官可以对这些问题上做一些改变以获取新奇和令人惊奇的元素，这对一次好的面试来说非常重要。而候选者，可以扩展和测试 Java 程序语言和平台关键领域的知识。2015 年，会更多的关注并发概念，JVM 内部，32 位 JVM 和 64 JVM的区别，单元测试及整洁的代码。我确信，如果你读过这个庞大的 Java 面试问题列表，无论是电话面试还是面对面的面试，你都能有很好的表现。</p><h2 id="Java-面试中的重要话题"><a href="#Java-面试中的重要话题" class="headerlink" title="Java 面试中的重要话题"></a><strong>Java 面试中的重要话题</strong></h2><p>除了你看到的惊人的问题数量，我也尽量保证质量。我不止一次分享各个重要主题中的问题，也确保包含所谓的高级话题，这些话题很多程序员不喜欢准备或者直接放弃，因为他们的工作不会涉及到这些。Java NIO 和 JVM 底层就是最好的例子。你也可以将设计模式划分到这一类中，但是越来越多有经验的程序员了解 GOF 设计模式并应用这些模式。我也尽量在这个列表中包含 2015 年最新的面试问题，这些问题可能是来年关注的核心。为了给你一个大致的了解,下面列出这份 Java 面试问题列表包含的主题：</p><ul><li>多线程，并发及线程基础</li><li>数据类型转换的基本原则</li><li>垃圾回收（GC）</li><li>Java 集合框架</li><li>数组</li><li>字符串</li><li>GOF 设计模式</li><li>SOLID （单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）设计原则</li><li>抽象类与接口</li><li>Java 基础，如 equals 和 hashcode</li><li>泛型与枚举</li><li>Java IO 与 NIO</li><li>常用网络协议</li><li>Java 中的数据结构和算法</li><li>正则表达式</li><li>JVM 底层</li><li>Java 最佳实践</li><li>JDBC</li><li>Date, Time 与 Calendar</li><li>Java 处理 XML</li><li>JUnit</li><li>编程</li></ul><h2 id="120-大-Java-面试题及答案"><a href="#120-大-Java-面试题及答案" class="headerlink" title="120 大 Java 面试题及答案"></a><strong>120 大 Java 面试题及答案</strong></h2><p>现在是时候给你展示我近 5 年从各种面试中收集来的 120 个问题了。我确定你在自己的面试中见过很多这些问题，很多问题你也能正确回答。</p><p>多线程、并发及线程的基础问题</p><p><strong>1）Java 中能创建 volatile 数组吗？</strong></p><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p><p><strong>2）volatile 能使得一个非原子操作变成原子操作吗？</strong></p><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p><p><strong>3）volatile 修饰符的有过什么实践？</strong></p><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p><p><strong>4）volatile 类型变量提供什么保证？</strong></p><p>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。</p><p><strong>5) 10 个线程和 2 个线程的同步代码，哪个更容易写？</strong></p><p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p><p><strong>6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</strong></p><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// The standard idiom for using the wait method</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">while</span> <span class="token punctuation">(</span>condition does not hold<span class="token punctuation">)</span>obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (Releases lock, and reacquires on wakeup)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">// Perform action appropriate to condition</span><span class="token punctuation">}</span></code></pre><p>参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。</p><p><strong>7）什么是多线程环境下的伪共享（false sharing）？</strong></p><p>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-a9557dcd20f2d034d8f2a28c643e7974_hd.jpg" alt="img"></p><p>伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。</p><h2 id="有经验程序员的-Java-面试题"><a href="#有经验程序员的-Java-面试题" class="headerlink" title="有经验程序员的 Java 面试题"></a><strong>有经验程序员的 Java 面试题</strong></h2><p><strong>8）什么是 Busy spin？我们为什么要使用它？</strong></p><p>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</p><p><strong>9）Java 中怎么获取一份线程 dump 文件？</strong></p><p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。</p><p><strong>10）Swing 是线程安全的？</strong></p><p>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。</p><p><strong>11）什么是线程局部变量？</strong></p><p>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)</p><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><p>ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。</p><p>ThreadLocal是如何为每个线程创建变量的副本的：</p><p>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p><p>总结：</p><p>a、实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的</p><p>b、为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；</p><p>c、在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法</p><p><strong>12）用 wait-notify 写一段代码来解决生产者-消费者问题？</strong></p><p>请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。</p><p><strong>13) 用 Java 写一个线程安全的单例模式（Singleton）？</strong></p><p>请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。</p><p><strong>14）Java 中 sleep 方法和 wait 方法的区别？</strong></p><p>虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。</p><p><strong>15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？</strong></p><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。</p><p><strong>16）我们能创建一个包含可变对象的不可变对象吗？</strong></p><p>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。</p><h2 id="数据类型和-Java-基础面试问题"><a href="#数据类型和-Java-基础面试问题" class="headerlink" title="数据类型和 Java 基础面试问题"></a><strong>数据类型和 Java 基础面试问题</strong></h2><p><strong>17）Java 中应该使用什么数据类型来代表价格？</strong></p><p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p><p><strong>18）怎么将 byte 转换为 String？</strong></p><p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p><p><strong>19）Java 中怎样将 bytes 转换为 long 类型？</strong></p><p>String接收bytes的构造器转成String，再Long.parseLong</p><p><strong>20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</strong></p><p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。</p><p><strong>21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；</strong></p><p>可以，向下转型。但是不建议使用，容易出现类型转型异常.</p><p><strong>22）哪个类包含 clone 方法？是 Cloneable 还是 Object？</strong></p><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p><p><strong>23）Java 中 ++ 操作符是线程安全的吗？</strong></p><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p><p><strong>24）a = a + b 与 a += b 的区别</strong></p><p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span> a <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// error : cannot convert from int to byte</span>b <span class="token operator">+=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ok</span></code></pre><p>（因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）</p><p><strong>25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？</strong></p><p>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</p><p><strong>26）3*0.1 == 0.3 将会返回什么？true 还是 false？</strong></p><p>false，因为有些浮点数不能完全精确的表示出来。</p><p><strong>27）int 和 Integer 哪个会占用更多的内存？</strong></p><p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p><p><strong>28）为什么 Java 中的 String 是不可变的（Immutable）？</strong></p><p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。</p><p><strong>29）我们能在 Switch 中使用 String 吗？</strong></p><p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p><p><strong>30）Java 中的构造器链是什么？</strong></p><p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p><h3 id="JVM-底层-与-GC（Garbage-Collection）-的面试问题"><a href="#JVM-底层-与-GC（Garbage-Collection）-的面试问题" class="headerlink" title="JVM 底层 与 GC（Garbage Collection） 的面试问题"></a><strong>JVM 底层 与 GC（Garbage Collection） 的面试问题</strong></h3><p><strong>31）64 位 JVM 中，int 的长度是多数？</strong></p><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p><p><strong>32）Serial 与 Parallel GC之间的不同之处？</strong></p><p>Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。</p><p><strong>33）32 位和 64 位的 JVM，int 类型变量的长度是多数？</strong></p><p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。</p><p><strong>34）Java 中 WeakReference 与 SoftReference的区别？</strong></p><p>Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。</p><p>StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收</p><p>WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在 JVM 内不再有强引用时, 将被GC回收</p><p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用</p><p><strong>35）WeakHashMap 是怎么工作的？</strong></p><p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。</p><p><strong>36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？</strong></p><p>当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。</p><p><strong>37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</strong></p><p>你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。</p><p><strong>38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</strong></p><p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p><p><strong>39）JRE、JDK、JVM 及 JIT 之间有什么不同？</strong></p><p>JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。</p><p><img src="https://pic4.zhimg.com/80/v2-dd8309180a824d7c2176dce812b2d28f_hd.jpg" alt="img"></p><h3 id="3-年工作经验的-Java-面试题"><a href="#3-年工作经验的-Java-面试题" class="headerlink" title="3 年工作经验的 Java 面试题"></a><strong>3 年工作经验的 Java 面试题</strong></h3><p><strong>40）解释 Java 堆空间及 GC？</strong></p><p>当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。</p><h3 id="JVM-底层面试题及答案"><a href="#JVM-底层面试题及答案" class="headerlink" title="JVM 底层面试题及答案"></a><strong>JVM 底层面试题及答案</strong></h3><p><strong>41）你能保证 GC 执行吗？</strong></p><p>不能，虽然你可以调用 System.gc() 或者 Runtime.getRuntime().gc()，但是没有办法保证 GC 的执行。</p><p><strong>42）怎么获取 Java 程序使用的内存？堆使用的百分比？</strong></p><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。</p><p><strong>43）Java 中堆和栈有什么区别？</strong></p><p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 Difference between stack and heap memory in Java</p><h3 id="关于内存的的面试问题和答案"><a href="#关于内存的的面试问题和答案" class="headerlink" title="关于内存的的面试问题和答案"></a><strong>关于内存的的面试问题和答案</strong></h3><p><strong>Java 基本概念面试题</strong></p><p><strong>44）“a==b”和”a.equals(b)”有什么区别？</strong></p><p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p><p><strong>45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</strong></p><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p><p><strong>46）final、finalize 和 finally 的不同之处？</strong></p><p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p><p><strong>47）Java 中的编译期常量是什么？使用它又什么风险？</strong></p><p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p><h3 id="Java-集合框架的面试题"><a href="#Java-集合框架的面试题" class="headerlink" title="Java 集合框架的面试题"></a><strong>Java 集合框架的面试题</strong></h3><p>这部分也包含数据结构、算法及数组的面试问题</p><p><strong>48) List、Set、Map 和 Queue 之间的区别(答案)</strong></p><p>List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。</p><p><strong>49）poll() 方法和 remove() 方法的区别？</strong></p><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p><p><strong>50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？(答案)</strong></p><p>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p><p><strong>51）ArrayList 与 LinkedList 的不区别？(答案)</strong></p><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。</p><p><strong>52）用哪两种方式来实现集合的排序？(答案)</strong></p><p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p><p><strong>53）Java 中怎么打印数组？(answer答案)</strong></p><p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p><p><strong>54）Java 中的 LinkedList 是单向链表还是双向链表？(答案)</strong></p><p>是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。</p><p><strong>55）Java 中的 TreeMap 是采用什么树实现的？(答案)</strong></p><p>Java 中的 TreeMap 是使用红黑树实现的。</p><p><strong>56) Hashtable 与 HashMap 有什么不同之处？(答案)</strong></p><p>这两个类有许多不同的地方，下面列出了一部分： a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。 b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。 c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。 更多的不同之处参见答案。</p><p><strong>57）Java 中的 HashSet，内部是如何工作的？(answer答案)</strong></p><p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p><p><strong>58）写一段代码在遍历 ArrayList 时移除一个元素？(答案)</strong></p><p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p><p><strong>59）我们能自己写一个容器类，然后使用 for-each 循环吗？</strong></p><p>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</p><p><strong>60）ArrayList 和 HashMap 的默认大小是多数？(答案)</strong></p><p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// from ArrayList.java JDK 1.7</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_CAPACITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//from HashMap.java JDK 7</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span></code></pre><p><strong>61）有没有可能两个不相等的对象有有相同的 hashcode？</strong></p><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p><p><strong>62）两个相同的对象会有不同的的 hash code 吗？</strong></p><p>不能，根据 hash code 的规定，这是不可能的。</p><p><strong>63）我们可以在 hashcode() 中使用随机数字吗？(答案)</strong></p><p>不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。</p><p><strong>64）Java 中，Comparator 与 Comparable 有什么不同？(答案)</strong></p><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p><p><strong>65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案)</strong></p><p>因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p><h3 id="Java-IO-和-NIO-的面试题"><a href="#Java-IO-和-NIO-的面试题" class="headerlink" title="Java IO 和 NIO 的面试题"></a><strong>Java IO 和 NIO 的面试题</strong></h3><p>IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。</p><p><strong>66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？</strong></p><p><strong>67）Java 中怎么创建 ByteBuffer？</strong></p><p><strong>68）Java 中，怎么读写 ByteBuffer ？</strong></p><p><strong>69）Java 采用的是大端还是小端？</strong></p><p><strong>70）ByteBuffer 中的字节序是什么？</strong></p><p><strong>71）Java 中，直接缓冲区与非直接缓冲器有什么区别？(答案)</strong></p><p><strong>72）Java 中的内存映射缓存区是什么？(answer答案)</strong></p><p><strong>73）socket 选项 TCP NO DELAY 是指什么？</strong></p><p><strong>74）TCP 协议与 UDP 协议有什么区别？(answer答案)</strong></p><p><strong>75）Java 中，ByteBuffer 与 StringBuffer有什么区别？(答案)</strong></p><h3 id="Java-最佳实践的面试问题"><a href="#Java-最佳实践的面试问题" class="headerlink" title="Java 最佳实践的面试问题"></a><strong>Java 最佳实践的面试问题</strong></h3><p>包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。</p><p><strong>76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？(答案)</strong></p><p>这是我在写Java 并发程序的时候遵循的一些最佳实践： a）给线程命名，这样可以帮助调试。 b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。 c）如果可以，更偏向于使用 volatile 而不是 synchronized。 d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。 e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p><p><strong>77）说出几点 Java 中使用 Collections 的最佳实践(答案)</strong></p><p>这是我在使用 Java 中 Collectionc 类的一些最佳实践： a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。 b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。 c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。 d）使用迭代器来循环集合。 e）使用集合的时候使用泛型。</p><p><strong>78）说出至少 5 点在 Java 中使用线程的最佳实践。(答案)</strong></p><p>这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该： a）对线程命名 b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。 c）使用线程池</p><p><strong>79）说出 5 条 IO 的最佳实践(答案)</strong></p><p>IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践： a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。 b）使用 NIO 和 NIO2 c）在 finally 块中关闭流，或者使用 try-with-resource（Java7） 语句。 d）使用内存映射文件获取更快的 IO。</p><p><strong>80）列出 5 个应该遵循的 JDBC 最佳实践(答案)</strong></p><p>有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则： a）使用批量的操作来插入和更新数据 b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。 c）使用数据库连接池 d）通过列名来获取结果集，不要使用列的下标来获取。</p><p><strong>81）说出几条 Java 中方法重载的最佳实践？(答案)</strong></p><p>下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。 a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。 b）不要重载参数数量一致，而只是参数顺序不同的方法。 c）如果重载的方法参数个数多于 5 个，采用可变参数。</p><h3 id="Date、Time-及-Calendar-的面试题"><a href="#Date、Time-及-Calendar-的面试题" class="headerlink" title="Date、Time 及 Calendar 的面试题"></a><strong>Date、Time 及 Calendar 的面试题</strong></h3><p><strong>82）在多线程环境下，SimpleDateFormat 是线程安全的吗？(答案)</strong></p><p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p><p><strong>83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？(答案)</strong></p><p>Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。</p><p><strong>84）Java 中，怎么在格式化的日期中显示时区？</strong></p><p>pattern中加z yyyy-MM-dd HH:mm:ss.SSS Z</p><p><strong>85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？</strong></p><p>java.sql.Date是针对SQL语句使用的，它只包含日期而没有时间部分,它们都有getTime方法返回毫秒数，自然就可以直接构建。java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。</p><p><strong>86）Java 中，如何计算两个日期之间的差距？</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dateDiff</span><span class="token punctuation">(</span>Date d1<span class="token punctuation">,</span> Date d2<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token keyword">long</span> n1 <span class="token operator">=</span> d1<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> n2 <span class="token operator">=</span> d2<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> diff <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n1 <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>diff <span class="token operator">/=</span> <span class="token number">3600</span> <span class="token operator">*</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">24</span><span class="token punctuation">;</span><span class="token keyword">return</span> diff<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>87）Java 中，如何将字符串 YYYYMMDD 转换为日期？</strong></p><p>SimpleDateFormat的parse方法</p><h3 id="单元测试-JUnit-面试题"><a href="#单元测试-JUnit-面试题" class="headerlink" title="单元测试 JUnit 面试题"></a><strong>单元测试 JUnit 面试题</strong></h3><p><strong>89）如何测试静态方法？(答案)</strong></p><p>可以使用 PowerMock 库来测试静态方法。</p><p><strong>90）怎么利用 JUnit 来测试一个方法的异常？(答案)</strong></p><p><strong>91）你使用过哪个单元测试库来测试你的 Java 程序？(答案)</strong></p><p><strong>92）@Before 和 @BeforeClass 有什么区别？(答案)</strong></p><h3 id="编程和代码相关的面试题"><a href="#编程和代码相关的面试题" class="headerlink" title="编程和代码相关的面试题"></a><strong>编程和代码相关的面试题</strong></h3><p><strong>93）怎么检查一个字符串只包含数字？(解决方案)</strong></p><p><strong>94）Java 中如何利用泛型写一个 LRU 缓存？(答案)</strong></p><p><strong>95）写一段 Java 程序将 byte 转换为 long？(答案)</strong></p><p><strong>95）在不使用 StringBuffer 的前提下，怎么反转一个字符串？(解决方案)</strong></p><p><strong>97）Java 中，怎么获取一个文件中单词出现的最高频率？(解决方案)</strong></p><p><strong>98）如何检查出两个给定的字符串是反序的？(解决方案)</strong></p><p><strong>99）Java 中，怎么打印出一个字符串的所有排列？(解决方案)</strong></p><p><strong>100）Java 中，怎样才能打印出数组中的重复元素？(解决方案)</strong></p><p><strong>101）Java 中如何将字符串转换为整数？(解决方案)</strong></p><p><strong>102）在没有使用临时变量的情况如何交换两个整数变量的值？(解决方案)</strong></p><h2 id="关于-OOP-和设计模式的面试题"><a href="#关于-OOP-和设计模式的面试题" class="headerlink" title="关于 OOP 和设计模式的面试题"></a><strong>关于 OOP 和设计模式的面试题</strong></h2><p>这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。</p><p><strong>103）接口是什么？为什么要使用接口而不是直接使用具体类？</strong></p><p>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。</p><p><strong>104）Java 中，抽象类与接口之间有什么不同？(答案)</strong></p><p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。</p><p><strong>105）除了单例模式，你在生产环境中还用过什么设计模式？</strong></p><p>这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。</p><p><strong>106）你能解释一下里氏替换原则吗?(答案)</strong></p><p><strong>107) 什么情况下会违反迪米特法则？为什么会有这个问题？(答案)</strong></p><p>迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。</p><p><strong>108）适配器模式是什么？什么时候使用？</strong></p><p>适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。</p><p><strong>109）什么是“依赖注入”和“控制反转”？为什么有人使用？(答案)</strong></p><p><strong>110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？(答案)</strong></p><p><strong>111）构造器注入和 setter 依赖注入，那种方式更好？(答案)</strong></p><p>每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。</p><p><strong>112）依赖注入和工厂模式之间有什么不同？(答案)</strong></p><p>虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。</p><p><strong>113）适配器模式和装饰器模式有什么区别？(答案)</strong></p><p>虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。</p><p><strong>114）适配器模式和代理模式之前有什么不同？(答案)</strong></p><p>这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。</p><p><strong>115）什么是模板方法模式？(答案)</strong></p><p>模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。</p><p><strong>116）什么时候使用访问者模式？(答案)</strong></p><p>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。</p><p><strong>117）什么时候使用组合模式？(答案)</strong></p><p>组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。</p><p><strong>118）继承和组合之间有什么不同？(答案)</strong></p><p>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</p><p><strong>119）描述 Java 中的重载和重写？(答案)</strong></p><p>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。</p><p><strong>120）Java 中，嵌套公共静态类与顶级类有什么不同？(答案)</strong></p><p>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</p><p><strong>121) OOP 中的 组合、聚合和关联有什么区别？(答案)</strong></p><p>如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。</p><p><strong>122）给我一个符合开闭原则的设计模式的例子？(答案)</strong></p><p>开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。</p><p><strong>123）抽象工厂模式和原型模式之间的区别？(答案)</strong></p><p><strong>124）什么时候使用享元模式？(答案)</strong></p><p>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。</p><h3 id="Java-面试中其他各式各样的问题"><a href="#Java-面试中其他各式各样的问题" class="headerlink" title="Java 面试中其他各式各样的问题"></a><strong>Java 面试中其他各式各样的问题</strong></h3><p>这部分包含 Java 中关于 XML 的面试题，JDBC 面试题，正则表达式面试题，Java 错误和异常及序列化面试题</p><p><strong>125）嵌套静态类与顶级类有什么区别？(答案)</strong></p><p>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。</p><p><strong>126）你能写出一个正则表达式来判断一个字符串是否是一个数字吗？(解决方案)</strong></p><p>一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，你可以下一个如下的正则表达式来判断给定的字符串是不是数字。</p><p><strong>127）Java 中，受检查异常 和 不受检查异常的区别？(答案)</strong></p><p>受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。</p><p><img src="https://pic2.zhimg.com/80/v2-5dc2ec13f7165dca5551f19df54803a5_hd.jpg" alt="img"></p><p><strong>128）Java 中，throw 和 throws 有什么区别？(答案)</strong></p><p>throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如： throw new IllegalArgumentException(“size must be multiple of 2″) 而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。</p><p><strong>129）Java 中，Serializable 与 Externalizable 的区别？(答案)</strong></p><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><p><strong>130）Java 中，DOM 和 SAX 解析器有什么不同？(答案)</strong></p><p>DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。</p><p><strong>131）说出 JDK 1.7 中的三个新特性？(答案)</strong></p><p>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。</p><p><strong>132）说出 5 个 JDK 1.8 引入的新特性？(答案)</strong></p><p>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性： Lambda 表达式，允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。 重复注解，现在你可以将相同的注解在同一类型上使用多次。</p><p><strong>133）Java 中，Maven 和 ANT 有什么区别？(答案)</strong></p><p>虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见答案。</p><p>这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP 和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web 开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建一份最新的、最优的 Java 面试问题列表。</p>]]></content>
      
      
      <categories>
          
          <category> java面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用画图工具推荐</title>
      <link href="/2018/12/23/%E5%B8%B8%E7%94%A8%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
      <url>/2018/12/23/%E5%B8%B8%E7%94%A8%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>平时学习的很多知识点，需要画图才能加强记忆，通过咨询大佬，总结几款比较好用的画图软件，希望能给大家提供些帮助。</p><p>1、lucidchart</p><p>2、draw.io</p><p>3、processon</p><p>4、sketch</p><p>5、画草图: <a href="https://www.autodraw.com/" target="_blank" rel="noopener">https://www.autodraw.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM知识点梳理</title>
      <link href="/2018/12/23/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
      <url>/2018/12/23/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>我复习java虚拟机用的是 周志明老师的《深入理解java虚拟机》这本书，同时结合极客时间上 郑雨迪老师讲的《深入拆解java虚拟机》。将重点知识在此进行梳理，方便日后回顾复习。</p><p>本文部分图片和内容来源于<a href="https://cyc2018.gitbooks.io/interview-notebook/content/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.html" target="_blank" rel="noopener">CyC2018博客</a></p><ul><li><h3 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h3><ul><li><h4 id="运行时数据区域："><a href="#运行时数据区域：" class="headerlink" title="运行时数据区域："></a>运行时数据区域：</h4><p><img src="https://img.mubu.com/document_image/154174f0-dab7-41b2-89bf-b8cc2da80f37-2160256.jpg" alt="img"></p></li><li><h4 id="程序计数器：-线程隔离，线程私有）"><a href="#程序计数器：-线程隔离，线程私有）" class="headerlink" title="程序计数器：(线程隔离，线程私有）"></a>程序计数器：(线程隔离，线程私有）</h4><p>可以看做是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。在任何一个确定的时刻，一个处理器（对于多处理器来说是一个内核）都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p></li><li><h4 id="java虚拟机栈：-线程私有）"><a href="#java虚拟机栈：-线程私有）" class="headerlink" title="java虚拟机栈：(线程私有）"></a>java虚拟机栈：(线程私有）</h4><p>生命周期与线程相同，虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储 局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p><img src="https://img.mubu.com/document_image/cbf98739-54fc-4479-a8f9-18515bf1174f-2160256.jpg" alt="img"></p><ul><li><h5 id="局部变量表："><a href="#局部变量表：" class="headerlink" title="局部变量表："></a>局部变量表：</h5><p>存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）局部变量表所需内存空间在编译期间完成分配。</p></li></ul></li><li><h4 id="本地方法栈：-线程私有）"><a href="#本地方法栈：-线程私有）" class="headerlink" title="本地方法栈：(线程私有）"></a>本地方法栈：(线程私有）</h4><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。它与虚拟机栈发挥的作用相似，他们之间的区别是：虚拟机栈为虚拟机执行java方法，本地方法栈为虚拟机使用到的native方法服务。</p><p><img src="https://img.mubu.com/document_image/6f530c3a-d740-47c8-b31a-cb434bb569b8-2160256.jpg" alt="img"></p></li><li><h4 id="java堆：-线程共享）"><a href="#java堆：-线程共享）" class="headerlink" title="java堆：(线程共享）"></a>java堆：(线程共享）</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，针对不同类型的对象采取不同的垃圾回收算法，可以将堆分成两块：</p><ul><li><h5 id="新生代（Young-Generation）"><a href="#新生代（Young-Generation）" class="headerlink" title="新生代（Young Generation）"></a>新生代（Young Generation）</h5><ul><li>Eden（伊甸园）</li><li>From Survivor（幸存者）</li><li>To Survivor</li></ul></li><li><h5 id="老年代（Old-Generation）"><a href="#老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h5><p>堆不需要连续内存，并且可以动态增加其内存，<strong>增加失败会抛出 OutOfMemoryError 异常</strong>。</p></li></ul></li><li><h4 id="方法区：-线程共享）"><a href="#方法区：-线程共享）" class="headerlink" title="方法区：(线程共享）"></a>方法区：(线程共享）</h4><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><ul><li>和堆一样不需要连续的内存，并且可以动态扩展，<strong>动态扩展失败一样会抛出 OutOfMemoryError 异常。</strong>对这块区域进行垃圾回收的主要目标是<strong>对常量池的回收和对类的卸载</strong>，但是一般比较难实现。JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收。但是从 JDK 1.7 开始，已经把原本放在永久代的字符串常量池移到 Native Method 中。</li><li>运行时常量池：<strong>是方法区的一部分</strong>，Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。</li></ul></li><li><h4 id="直接内存："><a href="#直接内存：" class="headerlink" title="直接内存："></a>直接内存：</h4><p>并不是虚拟机运行时数据区一部分，也不是java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。</p><ul><li>在 JDK 1.4 中新加入了 <strong>NIO 类</strong>，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里的 <strong>DirectByteBuffer 对象</strong>作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</li></ul></li><li><h4 id="对象的创建流程图："><a href="#对象的创建流程图：" class="headerlink" title="对象的创建流程图："></a>对象的创建流程图：</h4><p><img src="https://img.mubu.com/document_image/d5eaebc5-a8dd-41fb-b4c6-6c47c9396e0a-2160256.jpg" alt="img"></p><ul><li><h5 id="以上在堆中为新生对象分配内存的方式有2种"><a href="#以上在堆中为新生对象分配内存的方式有2种" class="headerlink" title="以上在堆中为新生对象分配内存的方式有2种:"></a>以上在堆中为新生对象分配内存的方式有2种:</h5><ul><li><strong>指针碰撞：</strong>假设java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的放一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。在使用<strong>Serial、ParNew等带Compact过程的收集器时</strong>，系统使用的分配算法是指针碰撞。</li><li><strong>空闲列表：</strong>若java堆内存不是规整的，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。而<strong>使用CMS这种基于Mark-Sweep算法的收集器时</strong>，通常使用空闲列表。</li></ul></li></ul></li></ul></li><li><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>​     垃圾收集主要是针对<strong>堆和方法区</strong>进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。</p><ul><li><h4 id="判断一个对象是否可被回收"><a href="#判断一个对象是否可被回收" class="headerlink" title="判断一个对象是否可被回收"></a>判断一个对象是否可被回收</h4><ul><li><h5 id="引用计数算法："><a href="#引用计数算法：" class="headerlink" title="引用计数算法："></a>引用计数算法：</h5><ul><li>给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</li><li>问题：两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</li></ul></li><li><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><ul><li><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。</p><p><img src="https://img.mubu.com/document_image/8d087a34-a0c3-426c-b020-450fd4804805-2160256.jpg" alt="img"></p></li><li><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul></li></ul></li><li><h5 id="方法区的回收："><a href="#方法区的回收：" class="headerlink" title="方法区的回收："></a>方法区的回收：</h5><ul><li>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。</li><li>主要是对常量池的回收和对类的卸载。</li><li>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。</li><li>类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：<ul><li>该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul></li></ul></li><li><h5 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h5><ul><li>finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</li><li>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</li></ul></li></ul></li></ul></li><li><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul><li><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>被软引用关联的对象<strong>只有在内存不够的情况下才会被回收</strong>。</p><p>使用 <strong>SoftReference 类</strong>来创建软引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SoftReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> sf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使对象只被软引用关联</span></code></pre></li><li><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到<strong>下一次垃圾回收发生之前</strong>。</p><p>使用 <strong>WeakReference</strong> 类来实现弱引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>WeakReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> wf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre></li><li><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p><p>为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</p><p>使用 <strong>PhantomReference</strong> 来实现虚引用。</p><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PhantomReference<span class="token operator">&lt;</span>Object<span class="token operator">></span> pf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><p>## </p></li></ul></li><li><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h4><p>将存活的对象进行标记，然后清理掉未被标记的对象。</p></li></ul></li></ul><p>  <img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/a4248c4b-6c1d-4fb8-a557-86da92d3a294.jpg" alt="img"></p><h5 id="不足："><a href="#不足：" class="headerlink" title="不足："></a><strong>不足</strong>：</h5><ol><li><p>标记和清除过程效率都不高。</p></li><li><p>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</p></li></ol><ul><li><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理</h4><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/902b83ab-8054-4bd2-898f-9a4a0fe52830.jpg" alt="img"></p></li></ul><ul><li><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/e6b733ad-606d-4028-b3e8-83c3a73a3797.jpg" alt="img"></p><ul><li><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p></li><li><p>主要不足是只使用了内存的一半。</p></li><li><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p></li><li><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p></li></ul></li><li><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul><li>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</li><li>一般将堆分为新生代和老年代：<ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除   /    标记 - 整理 算法</li></ul></li></ul></li></ul><ul><li><h3 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3></li></ul><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="img"></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><p>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</p><p>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并形指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p><ul><li><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/22fda4ae-4dd5-489d-ab10-9ebfdad22ae0.jpg" alt="img"></p><ul><li>Serial 翻译为串行，也就是说它以串行的方式执行。</li><li>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</li><li>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</li><li>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</li></ul></li><li><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/81538cd5-1bcf-4e31-86e5-e198df1e013b.jpg" alt="img"></p><ul><li>它是 Serial 收集器的多线程版本。</li><li>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</li><li>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</li></ul></li><li><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><ul><li>与 ParNew 一样是多线程收集器。</li><li>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。</li><li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li><li>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</li><li>可以通过一个开关参数打卡 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 。</li></ul></li><li><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/08f32fd3-f736-4a67-81ca-295b2a7972f2.jpg" alt="img"></p><ul><li>是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途：</li><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul></li><li><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/278fe431-af88-4a95-a895-9c3b80117de3.jpg" alt="img"></p><ul><li>是 Parallel Scavenge 收集器的老年代版本。</li><li>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</li></ul></li><li><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/62e77997-6957-4b68-8d12-bfd609bb2c68.jpg" alt="img"></p><ul><li>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</li><li>分为以下四个流程：</li><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li><li>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</li><li>具有以下缺点：</li><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul></li><li><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><ul><li><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p></li><li><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/4cf711a8-7ab2-4152-b85c-d5c226733807.png" alt="img"></p></li><li><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png" alt="img"></p></li><li><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p></li><li><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/f99ee771-c56f-47fb-9148-c0036695b5fe.jpg" alt="img"></p></li><li><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p></li><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</p></li><li><p>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p></li><li><p>具备如下特点：</p></li><li><p>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p></li><li><p>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java高并发程序设计知识总结</title>
      <link href="/2018/12/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2018/12/23/java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>最近把《实战java高并发程序设计》一书看了两遍，很多知识不加积累很快就忘记了，在此对java高并发这块知识进行总结，一方面自己回顾方便，另一方面可以给大家提供方便。</p><ul><li><h4 id="线程的母亲——进程"><a href="#线程的母亲——进程" class="headerlink" title="线程的母亲——进程"></a>线程的母亲——进程</h4><ul><li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li></ul></li><li><h4 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h4><ul><li>同步（Synchronous）和异步(Asynchronous)：同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。异步方法调用更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的工作。</li><li>并发(Concurrency)和并行(Parallelism)：并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义上的“同时执行”。</li><li>临界区：用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。在并行程序中，临界区资源是保护的对象。</li><li>阻塞（Blocking）和非阻塞(Non-Blocking)：他们用来形容多线程间的相互影响。如一个线程占用了临界区资源，那么其他所有需要这个资源的线程都必须等待，导致线程挂起，即阻塞。资源不释放，所有阻塞在临界区上的线程都不能工作。非阻塞与之相反，它指没有一个线程可以妨碍其他线程的执行。</li><li>死锁（DeadLock）：多个线程彼此占用了其他线程所需要的资源，得不到需要的资源，又不释放已得到的资源。</li><li>饥饿（Starvation）：指某一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。（如线程的优先级太低）还有一种情况，某一个线程一直占着资源不释放，导致其他需要这个资源的线程无法正常执行，与死锁相比，饥饿是有可能在未来一段时间内解决的。</li><li>活锁（LiveLock）：两个线程间，秉承“谦让”的原则，主动将资源释放给他人使用，可能会出现资源在两个线程中跳动，没有一个线程可以同时拿到所有资源而正常执行。</li></ul></li><li><h4 id="并发级别"><a href="#并发级别" class="headerlink" title="并发级别"></a>并发级别</h4><ul><li>阻塞（Blocking）：一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。使用synchronized关键字和ReentrantLock（重入锁）得到的就是阻塞线程。阻塞的控制方式是悲观策略。</li><li>无饥饿（Starvation-Free）：如果锁是公平的，满足先来后到，那饥饿就不会产生。</li><li>无障碍（Obstruction-Free）：无障碍是一种最弱的非阻塞调度。两个线程是无障碍地执行，那它们不会因为临界区的问题导致一方挂起，大家都可以大摇大摆地进入临界区。如果两个线程一起修改数据导致数据改坏了，则进行回滚， 保证数据安全。若没有数据竞争，则线程顺利完成工作，走出临界区。非阻塞的调度是一种乐观的策略。一种可行的无障碍实现可以依赖一个“一致性标记”来实现。</li><li>无锁（Lock-Free）：无锁的并行都是无障碍的。无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。如CAS操作。</li><li>无等待（Wait-Free）：它要求所有线程都必须在有限步内完成，这样就不会引起饥饿问题。</li></ul></li><li><h4 id="为什么要使用并行"><a href="#为什么要使用并行" class="headerlink" title="为什么要使用并行"></a>为什么要使用并行</h4><ul><li>为了获得更好的性能。</li><li>由于业务模型的需要，确实需要多个执行实体。</li></ul></li><li><h4 id="有关并行的两个重要定律"><a href="#有关并行的两个重要定律" class="headerlink" title="有关并行的两个重要定律"></a>有关并行的两个重要定律</h4><ul><li>Amdahl定律：加速比定义：加速比=优化前系统耗时/优化后系统耗时。 Amdahl定律强调，当串行比例一定时，加速比是有上限的，不管你堆叠多少CPU参与计算，都不能突破这个上限！</li><li>Gustafson定律：其关心的是：如果可被并行化的代码所占比重足够多，那么加速比就可以随着CPU的数量线性增长。</li></ul></li><li><h4 id="java内存模型（JMM）"><a href="#java内存模型（JMM）" class="headerlink" title="java内存模型（JMM）"></a>java内存模型（JMM）</h4><ul><li>原子性（Atomicity）: 原子性指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。对于32系统来说，Long类型的数据的读写不是原子性的（long有64位）。</li><li>可见性（Visibility）: 可见性是指当一个线程修改了某一个共享变量，其他线程是否能够立即知道这个修改。</li><li>有序性（Ordering）：单线程环境下，指令从前往后执行；多线程环境下，可能会进行指令重排，重排后的指令与原指令顺序未必一致。指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。</li></ul></li><li><h4 id="Happen-Before原则"><a href="#Happen-Before原则" class="headerlink" title="Happen-Before原则"></a>Happen-Before原则</h4><ul><li>程序顺序原则：一个线程内保证语义的串行性</li><li>volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性。</li><li>锁规则：解锁必然发生在随后的加锁前。</li><li>传递性：A先于B，B先于C，那么A必然先于C</li><li>线程的start()方法先于它的每一个动作</li><li>线程的所有操作先于线程的终结（Thread.join()）</li><li>线程的中断（interrupt（））先于被中断线程的代码</li><li>对象的构造函数执行、结束先于finalize()方法</li></ul></li><li><h3 id="java并行程序基础"><a href="#java并行程序基础" class="headerlink" title="java并行程序基础"></a>java并行程序基础</h3><ul><li><h4 id="线程状态转换："><a href="#线程状态转换：" class="headerlink" title="线程状态转换："></a>线程状态转换：</h4><p><img src="https://img.mubu.com/document_image/e1375cab-d57b-44a2-9a35-aed41db90124-2160256.jpg" alt="img"></p><ul><li>新建（New）：创建后尚未启动。</li><li>可运行（Runnable）：可能正在运行，也可能正在等待 CPU 时间片。包含了操作系统线程状态中的 Running 和 Ready。</li><li>阻塞（Blocking）: 等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li><li>无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</li><li>限期等待（Timed Waiting）无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</li><li>死亡（Terminated）：可以是线程结束任务之后自己结束，或者产生了异常而结束。</li></ul></li><li><h4 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h4><ul><li>实现Runnable接口</li><li>实现Callable接口</li><li>继承Thread类</li><li>说明：实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</li><li>三种实现方式的比较：<ul><li>实现Runnable接口可以避免Java单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。</li><li>继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法。</li><li>实现Callable接又要实现call方法，并且线程执行完毕后会有返回值。其他的两种都是重写run方法，没有返回值。</li><li>实现接口会更好一些，因为：①Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；②类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul></li></ul></li><li><h4 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h4><ul><li>Thread.stop()方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。若此时线程写入数据写到一半，并强行终止，那么对象就会被写坏，另一个线程读到不一致的对象。所以，不建议使用Thread.stop() 来终止线程</li><li>解决：可以定义一个标记变量 stopme, 用于指示线程是否需要退出，当调用线程终止方法（stopMe()）,stopme被设置为true,单线程执行到此，检测到改动，自然退出，不会使对象的状态出现错误。</li></ul></li><li><h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><ul><li>Thread.interrupt() : 是实例方法，通知目标线程中断，即设置中断标志位。</li><li>Thread.isInterrupted() ：是实例方法，判断当前线程是否有被中断。</li><li>Thread.interrupted() ：静态方法，判断当前线程的中断状态，但同时会清除当前线程的中断标志位状态</li></ul></li><li><h4 id="等待（wait）和通知（notify）"><a href="#等待（wait）和通知（notify）" class="headerlink" title="等待（wait）和通知（notify）"></a>等待（wait）和通知（notify）</h4><ul><li>object.wait()：如果一个线程调用了object.wait()，那么它就会进入object 对象的等待队列，这个等待队列，可能会有多个线程同时等待某一个对象。</li><li>object.notify()：如果object.notify()被调用时，它就会从这个等待队列中，随机选择一个线程，并将其唤醒。（注意：这个选择是不公平，随机的）</li><li>说明：object.wait()不能随便调用，它必须包含在对应的synchronized语句中，无论是wait()或者notify()都需要首先获得目标对象的一个监视器</li><li>object.wait()和Thread.sleep() : 两个方法都可以让线程等待若干时间，除了wait()可以被唤醒外，另外一个主要的区别就是wait()方法会释放目标对象的锁，Tread.sleep()方法不会释放任何资源。</li></ul></li><li><h4 id="挂起（suspend）和继续执行（resume）线程"><a href="#挂起（suspend）和继续执行（resume）线程" class="headerlink" title="挂起（suspend）和继续执行（resume）线程"></a>挂起（suspend）和继续执行（resume）线程</h4><ul><li>suspend在导致线程暂停的同时，并不会去释放任何锁资源。此时，其他线程想要访问被它暂用的锁时，都会被牵连，导致无法正常继续运行。直到对应的线程上进行了resume()操作，被挂起的线程才能继续，从而其他所有阻塞在相关锁上的线程也可以继续执行。所以不推荐使用suspend()去挂起线程</li><li>另外，如果resume()操作意外地在suspend()前就释放了，那么挂起的线程可能很难有机会继续执行。并且，更严重的是，它所占用的锁不会释放，因此可能导致整个系统工作不正常。（被挂起的线程，处于Runnable状态，让我们没办法对系统当前状态进行判断呀）</li></ul></li><li><h4 id="等待线程结束（join）和谦让（yield）"><a href="#等待线程结束（join）和谦让（yield）" class="headerlink" title="等待线程结束（join）和谦让（yield）"></a>等待线程结束（join）和谦让（yield）</h4><ul><li>join() 表示无限时等待，它会一直阻塞当前线程，直到目标线程执行完毕。join()的本质是让调用线程wait()在当前线程对象实例上。（调用线程等待当前线程）</li><li>join(long millis) 给出最大等待时间，如果超过给定时间目标线程还在执行，当前线程也会因“等不及了”，而继续往下执行。</li><li>Thread.yield()：是一个静态方法，一旦执行，会使当前线程让出CPU。但要注意，让出CPU并不表示当前线程不执行了，当前线程在让出CPU后，还会进行CPU资源的争夺，但能否再次分配到就不一定了。</li></ul></li><li><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><ul><li>当用volatile去声明一个变量的时候，就等于告诉了虚拟机，这个变量极有可能会被某些程序或者线程修改。</li><li>volatile能保证数据的可见性和有序性，不能保证原子性。</li></ul></li><li><h4 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h4><ul><li>ThreadGroup tg = new ThreadGroup(“ThreadGroup name”); 在创建线程和线程组的时候，给他们取一个好听的名字。</li></ul></li><li><h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><ul><li>守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地完成一些系统性的服务，比如垃圾回收线程，JIT线程可以理解为守护线程。</li><li>当一个java应用内，只有守护线程时，java虚拟机就会自然退出。</li><li>t.setDaemon(true); 将一个线程设置为守护线程。</li></ul></li><li><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li>在java中，使用1-10表示线程优先级，数字越大优先级越高</li><li>public final static int MIN_PRIORITY = 1;</li><li>public final static int NORM_PRIORITY = 5;</li><li>public final static int MAX_PRIORITY = 10;</li><li>thread.setPriority(Thread.MAX_PRIORITY ) // 为一个线程设置优先级</li></ul></li><li><h4 id="synchronized-的加锁方式"><a href="#synchronized-的加锁方式" class="headerlink" title="synchronized 的加锁方式"></a>synchronized 的加锁方式</h4><ul><li>同步一个代码块 ： 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</li><li>同步一个方法 ： 它和同步代码块一样，作用于同一个对象。</li><li>同步一个类： 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li><li>同步一个静态方法： 作用于整个类。</li></ul></li></ul></li><li><h3 id="JDK并发包："><a href="#JDK并发包：" class="headerlink" title="JDK并发包："></a>JDK并发包：</h3><ul><li><h4 id="同步控制："><a href="#同步控制：" class="headerlink" title="同步控制："></a>同步控制：</h4><ul><li><h5 id="ReentrantLock（重入锁-）"><a href="#ReentrantLock（重入锁-）" class="headerlink" title="ReentrantLock（重入锁 ）"></a>ReentrantLock（重入锁 ）</h5><ul><li>重入锁可以完全替代synchronized关键字，使用 java.util.concurrent.locks.ReentrantLock 类来实现。“重入”？：这种锁是可以反复进入的(这里的反复仅仅局限于一个线程),如果一个线程多次获得锁，那么在释放锁的时候，也必须释放相同次数的锁。</li><li>Synchronized与ReentrantLock比较：<ul><li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li>性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li>等待可中断: 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。</li><li>公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li></ul></li><li>lock.lock() 和 lock.lockInterruptibly()的区别：<ul><li>lock() 优先获得锁</li><li>lockInterruptibly() 优先相应中断</li></ul></li><li>锁申请等待限时 tryLock：<ul><li>lock.tryLock(5, TimeUnit.SECONDS) 参数表示等待时常， 计时单位</li><li>lock.tryLock(）不带参数时，申请锁成功立即返回true,申请失败，不会等待，立即返回false.</li></ul></li></ul></li><li><h5 id="Condition条件"><a href="#Condition条件" class="headerlink" title="Condition条件:"></a>Condition条件:</h5><ul><li>ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); //新建一个与lock绑定的condition对象</li><li>condition.await(); //让线程在Condition对象上等待，线程调用condition.await()时，要求线程持有相关的重入锁，在condition.await()调用之后，线程会释放这把锁</li><li>condition.signal(); //唤醒线程，condition.signal()方法调用时，也要求线程先获得相关的锁，在signal()方法调用之后，系统会从当前condition对象的等待队列中，唤醒一个线程。</li><li>ArrayBlockingQueue 的put()和take()方法使用的重入锁和Condition条件。</li></ul></li><li><h5 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）:"></a>信号量（Semaphore）:</h5><ul><li><p>信号量可以指定多个线程同时访问某个资源。</p></li><li><p>Semaphore semp = new Semaphore(5); //构造信号量对象，必须指定信号量准入数。</p></li><li><p>aquire() 方法尝试获得一个准入的许可。</p></li><li><p>acquireUninterruptibly() 不响应中断。</p></li><li><p>release() 用于在线程访问资源结束后，释放一个许可</p><p><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/Semaphore.png" alt="img"></p></li></ul></li><li><h5 id="读写锁（ReadWriteLock）："><a href="#读写锁（ReadWriteLock）：" class="headerlink" title="读写锁（ReadWriteLock）："></a>读写锁（ReadWriteLock）：</h5><ul><li>ReadWriteLock是jdk5中提供的读写分离锁，读写锁允许多个线程同时读，写写操作和读写操作间依然是需要相互等待和持有锁的。</li><li>ReentrantReadWriteLock readWritelock = new ReentrantReadWriteLock(); Lock readLock = readWritelock .readLock(); Lock writeLock = readWritelock .writeLock();</li></ul></li><li><h5 id="倒计时器-CountDownLatch"><a href="#倒计时器-CountDownLatch" class="headerlink" title="倒计时器(CountDownLatch):"></a>倒计时器(CountDownLatch):</h5><ul><li>控制线程等待，让某一线程等待直到倒计时结束，再开始执行。</li><li>CountDownLatch.countdown(); //通知CountDownLatch 一个线程已经完成，倒计时器可以减1了。</li><li>CountDownLatch.await(); //主线等待所有任务全部完成再往下执行 </li><li><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/CountdownLatch.png" alt="img"></li></ul></li><li><h5 id="循环栅栏（CyclicBarrier）"><a href="#循环栅栏（CyclicBarrier）" class="headerlink" title="循环栅栏（CyclicBarrier）:"></a>循环栅栏（CyclicBarrier）:</h5><ul><li>和CountDownLatch非常类似，但功能更加复杂且强大</li><li><img src="https://cyc2018.gitbooks.io/interview-notebook/content/pics/CyclicBarrier.png" alt="img"></li></ul></li><li><h5 id="线程阻塞工具类（LockSupport）"><a href="#线程阻塞工具类（LockSupport）" class="headerlink" title="线程阻塞工具类（LockSupport）:"></a>线程阻塞工具类（LockSupport）:</h5><ul><li>它可以在线程内任意位置让线程阻塞，和Thread.suspend()相比，它弥补了由于resume() 在前发生，导致线程无法继续执行的情况。</li><li>LockSupport.park()；//挂起线程 LockSupport.unpark() //让线程继续执行。</li><li>LockSupport 类使用类似信号量的机制，它为每一个线程准备了一个许可，如果许可可用，那么park()函数会立即返回，并且消费这个许可（即将许可变为不可用），如果许可不可用，就会阻塞，而unpark()则是使一个许可变为可用（但是和信号量不同的是，许可不能累加，你不可能拥有超过一个许可，他永远只有一个）。即使unpack() 操作发生在pack() 之前，它也可以使下一次的park() 操作立即返回。</li><li>park() 挂起状态的线程，会非常明确地给出一个WAITING状态，甚至还会标注是park() 引起的。</li></ul></li></ul></li><li><h4 id="线程池（Executor）"><a href="#线程池（Executor）" class="headerlink" title="线程池（Executor）"></a>线程池（Executor）</h4><p>为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。需要使用线程时，从线程池中随便拿一个空闲线程，完成工作后，并不着急关闭线程，而是将这个线程退回到线程池。</p><ul><li><p>Executor （线程池）：进行线程控制，管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p></li><li><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>Executor框架提供了各种类型的线程池：</p><ul><li>newFixedThreadPool()方法：返回一个固定数量的线程池，该线程池中的线程数量始终不变</li><li>newSingleThreadPool()方法：返回只有一个线程的线程池。（任务保存在任务队列）</li><li>newCachedThreadPool()方法：该方法返回一个可根据实际情况调整线程数量的线程池（线程池数量不固定，但若有空闲线程可复用，会优先使用可以复用的线程。没有空闲则会创建显得线程处理任务。）</li><li>newSingleThreadScheduledExecutor()方法：返回一个ScheduledExecutorService对象，线程池大小为1，功能：给定时间执行某任务。</li></ul></li></ul></li><li><h4 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h4><p>fork:创建子进程，使系统进程可以多一个执行分支</p><p>join:表示等待</p><p>fork/join例子如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> concurrency<span class="token punctuation">.</span>demo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ForkJoinPool<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Future<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>RecursiveTask<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ForkJoinExample</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threshold <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> last<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ForkJoinExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>last <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Integer <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&lt;=</span> threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 任务足够小则直接计算</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> last<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">+=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拆分成小任务</span>            <span class="token keyword">int</span> middle <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            ForkJoinExample leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>            ForkJoinExample rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>            leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        ForkJoinExample example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinExample</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ForkJoinPool forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Future result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>JDK的并发容器</p><ul><li><p>ConcurrentHashMap：位于java.util.concurrent 包内，是线程安全的HashMap</p><p>线程安全的HashMap：Collections.synchronizedMap(new HashMap());</p><p>线程安全的List：Collections.synchronizedList(new LinkedList<string>())</string></p></li><li><p>CopyOnWriteArrayList：是一个List，在读多写少的场合，这个List的性能非常好，远远好于Vector</p><p>性能极致？读取是完全不用加锁的，写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待。</p><p>过程：当List需要修改时，并不修改原有的内容，而是对原有的数据<strong>进行一次复制</strong>，将修改的内容写入副本中。写完以后，再将修改完的副本替换原来的数据，这样保证写操作不会影响读。</p><p>写入操作使用锁，这个锁仅限于控制写—写操作。</p></li><li><p>ConcurrentLinkedQueue：高效的并发队列，使用链表实现，可以看做是一个线程安全的LinkedList.算是高并发环境中性能最好的队列。  </p><p>使用CAS来执行执行向队列中添加元素 offer()，弹出元素 poll()</p></li><li><p>BlockingQueue：是一个接口，适合于用作数据共享的通道</p><ul><li><p>ArrayBlockingQueue：基于数组实现，适合作有界队列</p></li><li><p>LinkedBlockingQueue：基于链表实现，适合作无界队列或者边界值很大的队列。</p><p>操作：</p><p>往队列插入元素：offer()，  put() 会等待</p><p>从队列弹出元素：poll()  ， take() 会等待</p><p><strong>put()和take() 方法才是体现Blocking的关键。</strong></p></li></ul></li><li><p>ConcurrentSkipListMap：跳表的实现</p></li></ul></li></ul></li><li><h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><ul><li><p>提高锁性能的几点建议：</p><ul><li><p>减小锁持有的时间</p></li><li><p>减小锁粒度：如ConcurrentHashMap 内部细分为Segment，加锁是对Segment加锁。</p><p>求Map.size() 并不是直接取得全局锁，进行求和。而是先使用无锁的方式求和，如果失败才会尝试使用获得全局锁的方式进行计算</p></li><li><p>读写分离锁来替换独占锁：如 读写锁 ：ReadWriteLock</p></li><li><p>锁分离：如 LinkedBolckingQueue的实现，take()函数和put()函数分别作用于队列的前端和尾端。</p><p>通过takeLock 和putLock 两把锁，LinkedBolckingQueue实现了取数据和写数据的分离，使两者在真正意义上成为可并发的操作.</p></li><li><p>锁粗化：虚拟机在遇到一连串连续地对同一锁不断进行请求和释放操作时，便会把所有锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数。</p></li></ul></li><li><p>虚拟机对锁优化所做的努力：</p><ul><li></li></ul></li></ul></li></ul><p>  #### </p>]]></content>
      
      
      <categories>
          
          <category> java高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java高并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剑指Offer-48 ：最长不含重复字符的子字符串</title>
      <link href="/2018/12/21/%E5%89%91%E6%8C%87Offer-%E9%A2%9848%20%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/12/21/%E5%89%91%E6%8C%87Offer-%E9%A2%9848%20%EF%BC%9A%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="题目：最长不含重复字符的子字符串"><a href="#题目：最长不含重复字符的子字符串" class="headerlink" title="题目：最长不含重复字符的子字符串"></a>题目：最长不含重复字符的子字符串</h3><p>​      请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p><p><strong>主要思路：</strong></p><p>使用动态规划，记录当前字符之前的最长非重复子字符串长度f(i-1)，其中i为当前字符的位置。每次遍历当前字符时，分两种情况进行讨论：</p><ol><li>若当前字符第一次出现，则最长非重复子字符串长度f(i) = f(i-1)+1。 </li><li>若当前字符不是第一次出现，则首先计算当前字符与它上次出现位置之间的距离d。<br>若d大于f(i-1)，即说明前一个非重复子字符串中没有包含当前字符，则可以添加当前字符到前一个非重复子字符串中，所以，f(i) = f(i-1)+1。<br>若d小于或等于f(i-1)，即说明前一个非重复子字符串中已经包含当前字符，则不可以添加当前字符，所以，f(i) = d。</li></ol><p><strong>java代码实现：</strong></p><hr><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> offer<span class="token punctuation">.</span>coder<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TheMaxNoRepeatString48</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//测试代码</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getMaxNoRepeatString</span><span class="token punctuation">(</span><span class="token string">"abaacdwq"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMaxNoRepeatString</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">||</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> position <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化位置数组position</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> position<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            position<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> curLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 定位元素在数组中的下标 </span>            <span class="token keyword">int</span> index <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 上一个元素出现的位置</span>            <span class="token keyword">int</span> prePosition <span class="token operator">=</span> position<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 计算此次出现距上次出现的距离</span>            <span class="token keyword">int</span> distance <span class="token operator">=</span> i <span class="token operator">-</span> prePosition<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//距离 > 当前长度 ; 忽略，长度+1，继续判断下一个元素</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>prePosition <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> distance <span class="token operator">></span> curLength<span class="token punctuation">)</span><span class="token punctuation">{</span>                  curLength<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                                curLength <span class="token operator">=</span> distance<span class="token punctuation">;</span>                maxLength <span class="token operator">=</span> maxLength <span class="token operator">></span> curLength <span class="token operator">?</span> maxLength <span class="token operator">:</span> curLength<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                position<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxLength <span class="token operator">></span> curLength <span class="token operator">?</span> maxLength <span class="token operator">:</span> curLength<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何解释关系数据库的第一第二第三范式？</title>
      <link href="/2018/12/20/%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F/"/>
      <url>/2018/12/20/%E5%A6%82%E4%BD%95%E8%A7%A3%E9%87%8A%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AC%AC%E4%BA%8C%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。</p><h6 id="本文转自知乎刘慰教师"><a href="#本文转自知乎刘慰教师" class="headerlink" title="本文转自知乎刘慰教师"></a>本文转自知乎<a href="https://www.zhihu.com/question/24696366" target="_blank" rel="noopener">刘慰教师</a></h6><h1 id="范式介绍"><a href="#范式介绍" class="headerlink" title="范式介绍"></a>范式介绍</h1><p>   首先要明白”范式（NF）”是什么意思。按照教材中的定义，范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。很晦涩吧？实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。就像家里装修买建材，最环保的是E0级，其次是E1级，还有E2级等等。数据库范式也分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。</p><h1 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h1><h2 id="1NF的定义为：符合1NF的关系中的每个属性都不可再分。"><a href="#1NF的定义为：符合1NF的关系中的每个属性都不可再分。" class="headerlink" title="1NF的定义为：符合1NF的关系中的每个属性都不可再分。"></a>1NF的定义为：符合1NF的关系中的每个属性都不可再分。</h2><p>符合1NF的关系（你可以理解为数据表。“关系模式”和“关系”的区别，类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，你可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。<br>表1所示的情况，就不符合1NF的要求：</p><p><img src="https://img-blog.csdnimg.cn/20181220111349147.png" alt="表1"></p><p>实际上，<strong>1NF是所有关系型数据库的最基本要求</strong>，你在关系型数据库管理系统（RDBMS），例如SQL Server，Oracle，MySQL中创建数据表的时候，如果数据表的设计不符合这个最基本的要求，那么操作一定是不能成功的。也就是说，<strong>只要在RDBMS中已经存在的数据表，一定是符合1NF的</strong>。<br>如果我们要在RDBMS中表现表中的数据，就得设计为表2的形式：</p><p> <img src="https://img-blog.csdnimg.cn/20181220111517383.png" alt="表2"><br>但是仅仅符合1NF的设计，仍然会存在<strong>数据冗余过大，插入异常，删除异常，修改异常</strong>的问题，例如对于表3中的设计：<br><img src="https://img-blog.csdnimg.cn/20181220111559788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="表3"></p><ol><li>每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——<strong>数据冗余过大</strong></li><li>假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 ——<strong>插入异常</strong><br>根据三种关系完整性约束中实体完整性的要求，关系中的<strong>码</strong>所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将<strong>学号与课名的组合</strong>作为码，否则就无法唯一地区分每一条记录。[<strong>码</strong>：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）]。</li><li>假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——<strong>删除异常</strong></li><li><p>假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——<strong>修改异常</strong>。<br>正因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF），这就是所谓的“规范化”。</p><h1 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h1><h2 id="2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。"><a href="#2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。" class="headerlink" title="2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。"></a>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。</h2><p>第二范式（2NF）在关系理论中的严格定义我这里就不多介绍了（因为涉及到的铺垫比较多），只需要了解2NF对1NF进行了哪些改进即可。其改进是，2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。接下来对这句话中涉及到的四个概念———<strong>“函数依赖”、“码”、“非主属性”、与“部分函数依赖” </strong>进行一下解释。</p></li></ol><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>我们可以这么理解（但并不是特别严格的定义）：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说<strong>Y函数依赖于X，写作 X → Y</strong>。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也  就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。</p><p>例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说<strong>姓名函数依赖于学号，写作 学号 → 姓名</strong>。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。</p><p> <strong>表中,其他的函数依赖关系还有如：</strong></p><ul><li>系名 → 系主任</li><li>学号 → 系主任</li><li><p>（学号，课名） → 分数</p><p><strong>但以下函数依赖关系则不成立：</strong></p></li><li>学号 → 课名</li><li>学号 → 分数</li><li>课名 → 系主任</li><li>（学号，课名）→ 姓名<br>从“函数依赖”这个概念展开，还会有三个概念：<h5 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h5>在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ‘ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作：<br><img src="https://img-blog.csdnimg.cn/20181220113000872.png" alt="无"><br>例如： 学号 F→ 姓名 （学号，课名） F→ 分数  （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）</li></ul><h5 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h5><p>假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 ：<br><img src="https://img-blog.csdnimg.cn/20181220113146810.png" alt="在这里插入图片描述"><br>例如：（学号，课名） P→ 姓名</p><h5 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h5><p>假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （基于『Y 不包含于 X，且 X 不函数依赖于 Y』这个前提），那么我们就称 Z 传递函数依赖于 X ，记作：<br><img src="https://img-blog.csdnimg.cn/20181220141747431.png" alt="在这里插入图片描述"></p><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都<strong>完全函数依赖</strong>于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。<br>在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。<br>一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为<strong>主码</strong>）<br>例如：对于表3，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）</p><h3 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h3><p>包含在任何一个码中的属性成为主属性。<br>例如：<br>对于表3，主属性就有两个，学号 与 课名。</p><p>终于可以回过来看2NF了。<br>首先，我们需要判断，表3是否符合2NF的要求？<br>根据2NF的定义，判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。<br><strong>判断的方法是：</strong><br>第一步：找出数据表中所有的码。<br>第二步：根据第一步所得到的码，找出所有的主属性。<br>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<br>第四步：查看是否存在非主属性对码的部分函数依赖。<br>对于表3，根据前面所说的四步，<strong>我们可以这么做</strong>：<br>第一步：查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。……查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。看起来很麻烦是吧，但是这里有一个诀窍，就是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码了（因为作为码的要求里有一个“完全函数依赖”）。<br>图4表示了表中所有的函数依赖关系：<br><img src="https://img-blog.csdnimg.cn/20181220143506956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="图4"></p><p>这一步完成以后，可以得到，表3的码只有一个，就是（学号、课名）。<br>第二步：主属性有两个：学号 与 课名<br>第三步：非主属性有四个：姓名、系名、系主任、分数<br>第四步：对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 <strong>姓名</strong> 对码（学号，课名）的部分函数依赖。<br>对于（学号，课名）→ 系名，有 学号 → 系名，存在非主属性 <strong>系名</strong> 对码（学号，课名）的部分函数依赖。<br>对于（学号，课名） → 系主任，有 学号 → 系主任，存在非主属性 <strong>系主任</strong> 对码（学号，课名）的部分函数依赖。所以表3存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。</p><h3 id="部分函数依赖-1"><a href="#部分函数依赖-1" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>为了让表3符合2NF的要求，我们必须消除这些<strong>部分函数依赖</strong>，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”<strong>模式分解</strong>“。<br>模式分解的方法不是唯一的，以下是其中一种方法：<br><strong>选课（学号，课名，分数）</strong><br><strong>学生（学号，姓名，系名，系主任）</strong><br>我们先来判断以下，选课表与学生表，是否符合了2NF的要求？<br>   对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。<br>   对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。<br>图5表示了模式分解以后的新的函数依赖关系<br><img src="https://img-blog.csdnimg.cn/20181220144112622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="图5"><br>下图，表示了模式分解以后新的数据：<br><img src="https://img-blog.csdnimg.cn/20181220144157364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（这里还涉及到一个如何进行模式分解才是正确的知识点，先不介绍了）</p><p><strong>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</strong></p><ol><li>李小明转系到法律系只需要修改一次李小明对应的系的值即可。——有改进</li><li>数据冗余是否减少了？学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——有改进</li><li>删除某个系中所有的学生记录该系的信息仍然全部丢失。——无改进</li><li>插入一个尚无学生的新系的信息。因为学生表的码是学号，不能为空，所以此操作不被允许。——无改进</li></ol><p>所以说，仅仅符合2NF的要求，很多情况下还是不够的，而出现问题的原因，在于仍然存在非主属性系主任对于码学号的<strong>传递函数依赖</strong>。为了能进一步解决这些问题，我们还需要将符合2NF要求的数据表改进为符合3NF的要求。</p><h1 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h1><h2 id="3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。"><a href="#3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。" class="headerlink" title="3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。"></a>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。</h2><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖，也就是说， <strong>如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求</strong>。接下来我们看看表4中的设计，是否符合3NF的要求。<br> 对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在<strong>非主属性系主任对于码学号的传递函数依赖</strong>，所以学生表的设计，不符合3NF的要求。<br> 为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：<br> <strong>选课（学号，课名，分数）<br> 学生（学号，姓名，系名）<br> 系（系名，系主任）</strong><br> 对于选课表，符合3NF的要求，之前已经分析过了。<br> 对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。<br> 对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。<br><strong>新的依赖关系如图：</strong><br><img src="https://img-blog.csdnimg.cn/20181220144621632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>新的数据如表：</strong><br><img src="https://img-blog.csdnimg.cn/20181220144644734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在我们来看一下，进行同样的操作，是否还存在着之前的那些问题？</p><ol><li>删除某个系中所有的学生记录，该系的信息不会丢失。——有改进</li><li>插入一个尚无学生的新系的信息， 因为系表与学生表目前是独立的两张表，所以不影响。——有改进</li><li>数据冗余更加少了。——有改进</li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。</p><h1 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h1><h3 id="BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖"><a href="#BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖" class="headerlink" title="BCNF范式不存在主属性对于码的部分函数依赖与传递函数依赖"></a>BCNF范式不存在主属性对于码的<strong>部分函数依赖与传递函数依赖</strong></h3><p>要了解 BCNF 范式，那么先看这样一个问题：<br>若：某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？<br>答：<br><strong>函数依赖集：</strong>仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br><strong>码：</strong>（管理员，物品名），（仓库名，物品名）<br><strong>主属性：</strong>仓库名、管理员、物品名<br><strong>非主属性：</strong>数量<br><strong>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</strong><br>基于此关系模式的关系（具体的数据）可能如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20181220145111296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZoeTU2OTAzOTM1MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢</strong>？<br>我们来看以下几种操作：<br><strong>先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？</strong><br>——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。<br><strong>某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？</strong><br>——仓库本身与管理员的信息也被随之删除了。<br><strong>如果某仓库更换了管理员，会带来什么问题？</strong><br>——这个仓库有几条物品存放记录，就要修改多少次管理员信息。<br><strong>从这里我们可以得出结论：</strong><br>在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。<br><strong>造成此问题的原因：</strong><br>存在着主属性对于码的<strong>部分函数依赖与传递函数依赖</strong>。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖：<br>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）<br>这样，之前的插入异常，修改异常与删除异常的问题就被解决了。<br>以上就是关于 BCNF 的解释。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
